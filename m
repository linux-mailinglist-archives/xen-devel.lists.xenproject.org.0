Return-Path: <xen-devel-bounces@lists.xenproject.org>
X-Original-To: lists+xen-devel@lfdr.de
Delivered-To: lists+xen-devel@lfdr.de
Received: from lists.xenproject.org (lists.xenproject.org [192.237.175.120])
	by mail.lfdr.de (Postfix) with ESMTPS id B510D8ACB7B
	for <lists+xen-devel@lfdr.de>; Mon, 22 Apr 2024 12:58:03 +0200 (CEST)
Received: from list by lists.xenproject.org with outflank-mailman.709893.1108922 (Exim 4.92)
	(envelope-from <xen-devel-bounces@lists.xenproject.org>)
	id 1ryrMh-0007E7-So; Mon, 22 Apr 2024 10:57:39 +0000
X-Outflank-Mailman: Message body and most headers restored to incoming version
Received: by outflank-mailman (output) from mailman id 709893.1108922; Mon, 22 Apr 2024 10:57:39 +0000
Received: from localhost ([127.0.0.1] helo=lists.xenproject.org)
	by lists.xenproject.org with esmtp (Exim 4.92)
	(envelope-from <xen-devel-bounces@lists.xenproject.org>)
	id 1ryrMh-0007Bn-PM; Mon, 22 Apr 2024 10:57:39 +0000
Received: by outflank-mailman (input) for mailman id 709893;
 Mon, 22 Apr 2024 10:57:37 +0000
Received: from mail.xenproject.org ([104.130.215.37])
 by lists.xenproject.org with esmtp (Exim 4.92)
 (envelope-from <julien@xen.org>) id 1ryrMf-0007Bf-Qe
 for xen-devel@lists.xenproject.org; Mon, 22 Apr 2024 10:57:37 +0000
Received: from xenbits.xenproject.org ([104.239.192.120])
 by mail.xenproject.org with esmtp (Exim 4.92)
 (envelope-from <julien@xen.org>)
 id 1ryrMf-00042V-9f; Mon, 22 Apr 2024 10:57:37 +0000
Received: from gw1.octic.net ([88.97.20.152] helo=[10.0.0.211])
 by xenbits.xenproject.org with esmtpsa
 (TLS1.3:ECDHE_RSA_AES_128_GCM_SHA256:128) (Exim 4.92)
 (envelope-from <julien@xen.org>)
 id 1ryrMf-0000Ii-2M; Mon, 22 Apr 2024 10:57:37 +0000
X-BeenThere: xen-devel@lists.xenproject.org
List-Id: Xen developer discussion <xen-devel.lists.xenproject.org>
List-Unsubscribe: <https://lists.xenproject.org/mailman/options/xen-devel>,
 <mailto:xen-devel-request@lists.xenproject.org?subject=unsubscribe>
List-Post: <mailto:xen-devel@lists.xenproject.org>
List-Help: <mailto:xen-devel-request@lists.xenproject.org?subject=help>
List-Subscribe: <https://lists.xenproject.org/mailman/listinfo/xen-devel>,
 <mailto:xen-devel-request@lists.xenproject.org?subject=subscribe>
Errors-To: xen-devel-bounces@lists.xenproject.org
Precedence: list
Sender: "Xen-devel" <xen-devel-bounces@lists.xenproject.org>
DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed; d=xen.org;
	s=20200302mail; h=Content-Transfer-Encoding:Content-Type:In-Reply-To:From:
	References:Cc:To:Subject:MIME-Version:Date:Message-ID;
	bh=VLo7jqPPKBAMo2o0/G7+6Mu5upHw0Kanneg5HQw2ZLY=; b=NG8J5z7USeAf2311JapyAt5urb
	MJlb3cMihzAzTtabfU6po1pdqrQ2+L5iR6L6ts3YTC+Zz+ngUW5M9dTP+UnHuNgw3OwK4OUn9emV7
	jTCQ9q86/+K9JtbqXHZI4AewJAph/W+NBOBiPNvrL8RqbqxwoOsTeGwghd0R0RgawFXU=;
Message-ID: <89d268cc-bc49-4e22-b4e9-2e8dbe73124c@xen.org>
Date: Mon, 22 Apr 2024 11:57:35 +0100
MIME-Version: 1.0
User-Agent: Mozilla Thunderbird
Subject: Re: [XEN PATCH v2 4/5] xen/arm: allow dynamically assigned SGI
 handlers
Content-Language: en-GB
To: Jens Wiklander <jens.wiklander@linaro.org>, xen-devel@lists.xenproject.org
Cc: patches@linaro.org, Stefano Stabellini <sstabellini@kernel.org>,
 Bertrand Marquis <bertrand.marquis@arm.com>,
 Michal Orzel <michal.orzel@amd.com>,
 Volodymyr Babchuk <Volodymyr_Babchuk@epam.com>
References: <20240422073708.3663529-1-jens.wiklander@linaro.org>
 <20240422073708.3663529-5-jens.wiklander@linaro.org>
From: Julien Grall <julien@xen.org>
In-Reply-To: <20240422073708.3663529-5-jens.wiklander@linaro.org>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit

Hi Jens,

On 22/04/2024 08:37, Jens Wiklander wrote:
> Updates so request_irq() can be used with a dynamically assigned SGI irq
> as input. This prepares for a later patch where an FF-A schedule
> receiver interrupt handler is installed for an SGI generated by the
> secure world.

I would like to understand the use-case a bit more. Who is responsible 
to decide the SGI number? Is it Xen or the firmware?

If the later, how can we ever guarantee the ID is not going to clash 
with what the OS/hypervisor is using? Is it described in a 
specification? If so, please give a pointer.

> 
> gic_route_irq_to_xen() don't gic_set_irq_type() for SGIs since they are
> always edge triggered.
> 
> gic_interrupt() is updated to route the dynamically assigned SGIs to
> do_IRQ() instead of do_sgi(). The latter still handles the statically
> assigned SGI handlers like for instance GIC_SGI_CALL_FUNCTION.
> 
> Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
> ---
> v1->v2
> - Update patch description as requested
> ---
>   xen/arch/arm/gic.c | 5 +++--
>   xen/arch/arm/irq.c | 7 +++++--

I am not sure where to write the comment. But I think the comment on top 
of irq_set_affinity() in setup_irq() should also be updated.

>   2 files changed, 8 insertions(+), 4 deletions(-)
> 
> diff --git a/xen/arch/arm/gic.c b/xen/arch/arm/gic.c
> index 44c40e86defe..e9aeb7138455 100644
> --- a/xen/arch/arm/gic.c
> +++ b/xen/arch/arm/gic.c
> @@ -117,7 +117,8 @@ void gic_route_irq_to_xen(struct irq_desc *desc, unsigned int priority)
>   
>       desc->handler = gic_hw_ops->gic_host_irq_type;
>   
> -    gic_set_irq_type(desc, desc->arch.type);
> +    if ( desc->irq >= NR_GIC_SGI)
> +        gic_set_irq_type(desc, desc->arch.type);

So above, you say that the SGIs are always edge-triggered interrupt. So 
I assume desc->arch.type. So are you skipping the call because it is 
unnessary or it could do the wrong thing?

Ideally, the outcome of the answer be part of the comment on top of the 
check.

>       gic_set_irq_priority(desc, priority);
>   }
>   
> @@ -375,7 +376,7 @@ void gic_interrupt(struct cpu_user_regs *regs, int is_fiq)
>           /* Reading IRQ will ACK it */
>           irq = gic_hw_ops->read_irq();
>   
> -        if ( likely(irq >= 16 && irq < 1020) )
> +        if ( likely(irq >= GIC_SGI_MAX && irq < 1020) )

This check is now rather confusing as one could think that do_IRQ() 
would still not be reached for dynamic SGI. I think it would be clearer 
GIC_SGI_MAX needs to be renamed to GIC_SGI_STATIC_MAX and do_sgi() to 
do_static_sgi().

>           {
>               isb();
>               do_IRQ(regs, irq, is_fiq);
> diff --git a/xen/arch/arm/irq.c b/xen/arch/arm/irq.c
> index bcce80a4d624..fdb214560978 100644
> --- a/xen/arch/arm/irq.c
> +++ b/xen/arch/arm/irq.c
> @@ -224,9 +224,12 @@ void do_IRQ(struct cpu_user_regs *regs, unsigned int irq, int is_fiq)
>   
>       perfc_incr(irqs);
>   
> -    ASSERT(irq >= 16); /* SGIs do not come down this path */
> +    /* Statically assigned SGIs do not come down this path */
> +    ASSERT(irq >= GIC_SGI_MAX);


With this change, I think the path with vgic_inject_irq() now needs to 
gain an ASSERT(irq >= NR_GIC_SGI) because the path is not supposed to be 
taken for SGIs.

>   
> -    if ( irq < 32 )
> +    if ( irq < NR_GIC_SGI )
> +        perfc_incr(ipis);
> +    else if ( irq < NR_GIC_LOCAL_IRQS )
>           perfc_incr(ppis);
>       else
>           perfc_incr(spis);

Cheers,

-- 
Julien Grall


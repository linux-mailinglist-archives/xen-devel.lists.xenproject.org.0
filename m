Return-Path: <xen-devel-bounces@lists.xenproject.org>
X-Original-To: lists+xen-devel@lfdr.de
Delivered-To: lists+xen-devel@lfdr.de
Received: from lists.xenproject.org (lists.xenproject.org [192.237.175.120])
	by mail.lfdr.de (Postfix) with ESMTPS id 247A468DDA2
	for <lists+xen-devel@lfdr.de>; Tue,  7 Feb 2023 17:11:54 +0100 (CET)
Received: from list by lists.xenproject.org with outflank-mailman.491326.760401 (Exim 4.92)
	(envelope-from <xen-devel-bounces@lists.xenproject.org>)
	id 1pPQYU-00008o-Bf; Tue, 07 Feb 2023 16:10:50 +0000
X-Outflank-Mailman: Message body and most headers restored to incoming version
Received: by outflank-mailman (output) from mailman id 491326.760401; Tue, 07 Feb 2023 16:10:50 +0000
Received: from localhost ([127.0.0.1] helo=lists.xenproject.org)
	by lists.xenproject.org with esmtp (Exim 4.92)
	(envelope-from <xen-devel-bounces@lists.xenproject.org>)
	id 1pPQYU-00005n-7F; Tue, 07 Feb 2023 16:10:50 +0000
Received: by outflank-mailman (input) for mailman id 491326;
 Tue, 07 Feb 2023 16:10:48 +0000
Received: from se1-gles-flk1-in.inumbo.com ([94.247.172.50]
 helo=se1-gles-flk1.inumbo.com)
 by lists.xenproject.org with esmtp (Exim 4.92) (envelope-from
 <SRS0=if6N=6D=citrix.com=prvs=3954b4a48=anthony.perard@srs-se1.protection.inumbo.net>)
 id 1pPQYR-00005d-7h
 for xen-devel@lists.xenproject.org; Tue, 07 Feb 2023 16:10:48 +0000
Received: from esa3.hc3370-68.iphmx.com (esa3.hc3370-68.iphmx.com
 [216.71.145.155]) by se1-gles-flk1.inumbo.com (Halon) with ESMTPS
 id dc866d85-a701-11ed-93b5-47a8fe42b414;
 Tue, 07 Feb 2023 17:10:09 +0100 (CET)
X-BeenThere: xen-devel@lists.xenproject.org
List-Id: Xen developer discussion <xen-devel.lists.xenproject.org>
List-Unsubscribe: <https://lists.xenproject.org/mailman/options/xen-devel>,
 <mailto:xen-devel-request@lists.xenproject.org?subject=unsubscribe>
List-Post: <mailto:xen-devel@lists.xenproject.org>
List-Help: <mailto:xen-devel-request@lists.xenproject.org?subject=help>
List-Subscribe: <https://lists.xenproject.org/mailman/listinfo/xen-devel>,
 <mailto:xen-devel-request@lists.xenproject.org?subject=subscribe>
Errors-To: xen-devel-bounces@lists.xenproject.org
Precedence: list
Sender: "Xen-devel" <xen-devel-bounces@lists.xenproject.org>
X-Inumbo-ID: dc866d85-a701-11ed-93b5-47a8fe42b414
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple;
  d=citrix.com; s=securemail; t=1675786209;
  h=from:to:cc:subject:date:message-id:mime-version:
   content-transfer-encoding;
  bh=B7PmvqwHTmYEXj8KCOsl8OPJeetpt8oR6BHQJvweCgU=;
  b=SfYraN6gpqDtJNWvT9/K5IkFmsfzPhMFJg7vSlCTWZ4q4KbQiN8E0t3W
   aX4G480iTCzXo8XHfYE92qr8W9MDu0LSqFREec5B9rOOt0jtx355+MFWM
   JMBZbj3JLLDIlhrgpxfU7xtaMLEzKO3u3SkpNXkMHDrpw78tHU4zNmcXX
   Q=;
Authentication-Results: esa3.hc3370-68.iphmx.com; dkim=none (message not signed) header.i=none
X-SBRS: 4.0
X-MesageID: 96052655
X-Ironport-Server: esa3.hc3370-68.iphmx.com
X-Remote-IP: 162.221.156.123
X-Policy: $RELAYED
IronPort-Data: A9a23:rAZX2qJ6Ww3H8zcCFE+RxJUlxSXFcZb7ZxGr2PjKsXjdYENS0GABm
 jBNCmCBMveCNGamKdAlYYTj8hgCuJbXnNVqT1ZlqX01Q3x08seUXt7xwmUcnc+xBpaaEB84t
 ZV2hv3odp1coqr0/0/1WlTZhSAgk/rOHvykU7Ss1hlZHWdMUD0mhQ9oh9k3i4tphcnRKw6Ws
 Jb5rta31GWNglaYCUpJrfPcwP9TlK6q4mhA5ARhPakjUGL2zBH5MrpOfcldEFOgKmVkNrbSb
 /rOyri/4lTY838FYj9yuu+mGqGiaue60Tmm0hK6aYD76vRxjnVaPpIAHOgdcS9qZwChxLid/
 jnvWauYEm/FNoWU8AgUvoIx/ytWZcWq85efSZSzXFD6I+QrvBIAzt03ZHzaM7H09c5IKF922
 MUfDgwASQKGq9mf4+6lEdNz05FLwMnDZOvzu1llxDDdS/0nXYrCU+PB4towMDUY354UW6yEP
 oxANGQpNU6bC/FMEg5/5JYWleG0hn75YntApUicv6Yf6GnP1g1hlrPqNbI5f/TbG50IxBjF+
 woq+UzhOjQnMZ+h9ADdsVG8jbHdvBLdW5wrQejQGvlC3wTImz175ActfUS/iem0jAi5Qd03A
 04b4C01toAp6VemCNL6WnWQsHOC+xIRRddUO+k78x2WjLrZ5R6DAWoJRSIHb8Yp3PLaXhRzi
 AXPxYmwQ2Uy7vvMEyn1GqqoQS2aBgErFUI7Ygk4QCwX5vXYiaJvkEn1UYM2eEKqteHdFTb1y
 jGMiSExgbQPkMIGv5mGEUD7byGE/caQEFNsjunDdif8t14iOtb5D2C9wQKDhcusOrp1WbVoU
 JIsv8GFpN4DApiW/MBmaLVcRer5jxpp3dC1vLKOI3XD3271k5JAVdoKiN2bGKuOGphsRNMRS
 BWP0T69HbcKVJdQUYd5YpiqF+MhxrX6GNLuW5j8N4QRP8cpJFPfo300PyZ8OlwBd2B1wMkC1
 WqzK57wXR7294w3pNZJewvt+eBynX1vrY8ibZv60w6mwdKjiI29EN843K+1Rrlhtsus+VyFm
 +uzwuPWk32zpsWiOHiImWPSRHhWRUUG6Wfe8ZMKK7DdeVc8SAnMyZb5mNscRmCspIwN/s+gw
 513chUwJIbX7ZEfFTi3Vw==
IronPort-HdrOrdr: A9a23:Q28U569pXTnGaBmAfgJuk+DxI+orL9Y04lQ7vn2ZKCYlEPBw8v
 rFoB1173LJYVoqNE3I4OrwXpVoIkmslqKdg7NxAV7KZmCPhILPFu5fBODZowEIdReRygdr79
 YET0EvMrbN5IBB/L7HCdODYrEdKQS8gcSVbDvlvg5QpN9RGtpd0zs=
X-IronPort-AV: E=Sophos;i="5.97,278,1669093200"; 
   d="scan'208";a="96052655"
From: Anthony PERARD <anthony.perard@citrix.com>
To: <xen-devel@lists.xenproject.org>
CC: Anthony PERARD <anthony.perard@citrix.com>, Wei Liu <wl@xen.org>, "Juergen
 Gross" <jgross@suse.com>
Subject: [XEN PATCH] tools: Have flex and bison mandatory
Date: Tue, 7 Feb 2023 16:09:48 +0000
Message-ID: <20230207160948.3169-1-anthony.perard@citrix.com>
X-Mailer: git-send-email 2.30.2
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain

Both are already mandatory to build the hypervisor.

This will help avoid cases where the *.y or *.l files are been updated
but flex and bison aren't available.

This also remove the way the missing binaries are been handled, with
double-column-rules, which might be an issue sometime.

Adding ".SECONDARY:" to avoid "libxlu_cfg_y.c" been deleted by make
when building the library, and regenerating the file on the first
incremental build.

Signed-off-by: Anthony PERARD <anthony.perard@citrix.com>
---
 tools/configure                 |  142 +-
 tools/configure.ac              |    8 +-
 tools/libs/util/.gitignore      |    1 +
 tools/libs/util/Makefile        |   21 +-
 tools/libs/util/libxlu_cfg_l.c  | 2375 ------------------------
 tools/libs/util/libxlu_cfg_l.h  |  734 --------
 tools/libs/util/libxlu_cfg_y.c  | 1705 ------------------
 tools/libs/util/libxlu_cfg_y.h  |   96 -
 tools/libs/util/libxlu_disk_l.c | 2975 -------------------------------
 tools/libs/util/libxlu_disk_l.h |  701 --------
 10 files changed, 60 insertions(+), 8698 deletions(-)
 create mode 100644 tools/libs/util/.gitignore
 delete mode 100644 tools/libs/util/libxlu_cfg_l.c
 delete mode 100644 tools/libs/util/libxlu_cfg_l.h
 delete mode 100644 tools/libs/util/libxlu_cfg_y.c
 delete mode 100644 tools/libs/util/libxlu_cfg_y.h
 delete mode 100644 tools/libs/util/libxlu_disk_l.c
 delete mode 100644 tools/libs/util/libxlu_disk_l.h

diff --git a/tools/configure b/tools/configure
index dae377c982..75ae8caa5b 100755
--- a/tools/configure
+++ b/tools/configure
@@ -5448,6 +5448,51 @@ test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
 
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
+# Extract the first word of "bison", so it can be a program name with args.
+set dummy bison; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_BISON+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $BISON in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_BISON="$BISON" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_BISON="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_BISON" && ac_cv_path_BISON="no"
+  ;;
+esac
+fi
+BISON=$ac_cv_path_BISON
+if test -n "$BISON"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $BISON" >&5
+$as_echo "$BISON" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+if test x"${BISON}" = x"no"
+then
+    as_fn_error $? "Unable to find bison, please install bison" "$LINENO" 5
+fi
 # Extract the first word of "flex", so it can be a program name with args.
 set dummy flex; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -5475,6 +5520,7 @@ done
   done
 IFS=$as_save_IFS
 
+  test -z "$ac_cv_path_FLEX" && ac_cv_path_FLEX="no"
   ;;
 esac
 fi
@@ -5488,6 +5534,10 @@ $as_echo "no" >&6; }
 fi
 
 
+if test x"${FLEX}" = x"no"
+then
+    as_fn_error $? "Unable to find flex, please install flex" "$LINENO" 5
+fi
 # Extract the first word of "abi-dumper", so it can be a program name with args.
 set dummy abi-dumper; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -10117,98 +10167,6 @@ else
 fi
 
 
-if test "x$pvshim" = "xy"; then :
-
-    # Extract the first word of "bison", so it can be a program name with args.
-set dummy bison; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_BISON+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $BISON in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_BISON="$BISON" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_BISON="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_path_BISON" && ac_cv_path_BISON="no"
-  ;;
-esac
-fi
-BISON=$ac_cv_path_BISON
-if test -n "$BISON"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $BISON" >&5
-$as_echo "$BISON" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-if test x"${BISON}" = x"no"
-then
-    as_fn_error $? "Unable to find bison, please install bison" "$LINENO" 5
-fi
-
-else
-
-    # Extract the first word of "bison", so it can be a program name with args.
-set dummy bison; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_BISON+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $BISON in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_BISON="$BISON" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_BISON="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  ;;
-esac
-fi
-BISON=$ac_cv_path_BISON
-if test -n "$BISON"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $BISON" >&5
-$as_echo "$BISON" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-
-fi
 
 
 ax_found=0
diff --git a/tools/configure.ac b/tools/configure.ac
index 3a2f6a2da9..1a714d9ff7 100644
--- a/tools/configure.ac
+++ b/tools/configure.ac
@@ -298,7 +298,8 @@ AC_ARG_VAR([AWK], [Path to awk tool])
 AC_PROG_CC
 AC_PROG_MAKE_SET
 AC_PROG_INSTALL
-AC_PATH_PROG([FLEX], [flex])
+AX_PATH_PROG_OR_FAIL([BISON], [bison])
+AX_PATH_PROG_OR_FAIL([FLEX], [flex])
 AC_PATH_PROG([ABI_DUMPER], [abi-dumper])
 AX_PATH_PROG_OR_FAIL([PERL], [perl])
 AX_PATH_PROG_OR_FAIL([AWK], [awk])
@@ -512,11 +513,6 @@ AC_ARG_ENABLE([pvshim],
     esac
 ])
 AC_SUBST(pvshim)
-AS_IF([test "x$pvshim" = "xy"], [
-    AX_PATH_PROG_OR_FAIL([BISON], [bison])
-], [
-    AC_PATH_PROG([BISON], [bison])
-])
 
 AX_FIND_HEADER([INCLUDE_ENDIAN_H], [endian.h sys/endian.h])
 
diff --git a/tools/libs/util/.gitignore b/tools/libs/util/.gitignore
new file mode 100644
index 0000000000..63e62ad066
--- /dev/null
+++ b/tools/libs/util/.gitignore
@@ -0,0 +1 @@
+/libxlu_*_[ly].[ch]
diff --git a/tools/libs/util/Makefile b/tools/libs/util/Makefile
index e016baf888..93ebf930a4 100644
--- a/tools/libs/util/Makefile
+++ b/tools/libs/util/Makefile
@@ -16,18 +16,6 @@ CFLAGS += $(CFLAGS_libxenctrl)
 CFLAGS += $(PTHREAD_CFLAGS)
 LDFLAGS += $(PTHREAD_LDFLAGS)
 
-ifeq ($(FLEX),)
-%.c %.h:: %.l
-	$(warning Flex is needed to rebuild some libxl parsers and \
-		  scanners, please install it and rerun configure)
-endif
-
-ifeq ($(BISON),)
-%.c %.h:: %.y
-	$(warning Bison is needed to rebuild some libxl parsers and \
-		  scanners, please install it and rerun configure)
-endif
-
 AUTOINCS = libxlu_cfg_y.h libxlu_cfg_l.h libxlu_disk_l.h
 
 LIBHEADER := libxlutil.h
@@ -40,10 +28,15 @@ include $(XEN_ROOT)/tools/libs/libs.mk
 
 $(OBJS-y) $(PIC_OBJS): $(AUTOINCS)
 
-%.c %.h:: %.y
+%.c %.h: %.y
 	@rm -f $*.[ch]
 	$(BISON) --output=$*.c $<
 
-%.c %.h:: %.l
+%.c %.h: %.l
 	@rm -f $*.[ch]
 	$(FLEX) --header-file=$*.h --outfile=$*.c $<
+
+clean::
+	$(RM) libxlu_*_[ly].[ch]
+
+.SECONDARY:
diff --git a/tools/libs/util/libxlu_cfg_l.c b/tools/libs/util/libxlu_cfg_l.c
deleted file mode 100644
index 406b50a037..0000000000
--- a/tools/libs/util/libxlu_cfg_l.c
+++ /dev/null
@@ -1,2375 +0,0 @@
-#line 2 "libxlu_cfg_l.c"
-
-#line 4 "libxlu_cfg_l.c"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 4
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-#ifdef yy_create_buffer
-#define xlu__cfg_yy_create_buffer_ALREADY_DEFINED
-#else
-#define yy_create_buffer xlu__cfg_yy_create_buffer
-#endif
-
-#ifdef yy_delete_buffer
-#define xlu__cfg_yy_delete_buffer_ALREADY_DEFINED
-#else
-#define yy_delete_buffer xlu__cfg_yy_delete_buffer
-#endif
-
-#ifdef yy_scan_buffer
-#define xlu__cfg_yy_scan_buffer_ALREADY_DEFINED
-#else
-#define yy_scan_buffer xlu__cfg_yy_scan_buffer
-#endif
-
-#ifdef yy_scan_string
-#define xlu__cfg_yy_scan_string_ALREADY_DEFINED
-#else
-#define yy_scan_string xlu__cfg_yy_scan_string
-#endif
-
-#ifdef yy_scan_bytes
-#define xlu__cfg_yy_scan_bytes_ALREADY_DEFINED
-#else
-#define yy_scan_bytes xlu__cfg_yy_scan_bytes
-#endif
-
-#ifdef yy_init_buffer
-#define xlu__cfg_yy_init_buffer_ALREADY_DEFINED
-#else
-#define yy_init_buffer xlu__cfg_yy_init_buffer
-#endif
-
-#ifdef yy_flush_buffer
-#define xlu__cfg_yy_flush_buffer_ALREADY_DEFINED
-#else
-#define yy_flush_buffer xlu__cfg_yy_flush_buffer
-#endif
-
-#ifdef yy_load_buffer_state
-#define xlu__cfg_yy_load_buffer_state_ALREADY_DEFINED
-#else
-#define yy_load_buffer_state xlu__cfg_yy_load_buffer_state
-#endif
-
-#ifdef yy_switch_to_buffer
-#define xlu__cfg_yy_switch_to_buffer_ALREADY_DEFINED
-#else
-#define yy_switch_to_buffer xlu__cfg_yy_switch_to_buffer
-#endif
-
-#ifdef yypush_buffer_state
-#define xlu__cfg_yypush_buffer_state_ALREADY_DEFINED
-#else
-#define yypush_buffer_state xlu__cfg_yypush_buffer_state
-#endif
-
-#ifdef yypop_buffer_state
-#define xlu__cfg_yypop_buffer_state_ALREADY_DEFINED
-#else
-#define yypop_buffer_state xlu__cfg_yypop_buffer_state
-#endif
-
-#ifdef yyensure_buffer_stack
-#define xlu__cfg_yyensure_buffer_stack_ALREADY_DEFINED
-#else
-#define yyensure_buffer_stack xlu__cfg_yyensure_buffer_stack
-#endif
-
-#ifdef yylex
-#define xlu__cfg_yylex_ALREADY_DEFINED
-#else
-#define yylex xlu__cfg_yylex
-#endif
-
-#ifdef yyrestart
-#define xlu__cfg_yyrestart_ALREADY_DEFINED
-#else
-#define yyrestart xlu__cfg_yyrestart
-#endif
-
-#ifdef yylex_init
-#define xlu__cfg_yylex_init_ALREADY_DEFINED
-#else
-#define yylex_init xlu__cfg_yylex_init
-#endif
-
-#ifdef yylex_init_extra
-#define xlu__cfg_yylex_init_extra_ALREADY_DEFINED
-#else
-#define yylex_init_extra xlu__cfg_yylex_init_extra
-#endif
-
-#ifdef yylex_destroy
-#define xlu__cfg_yylex_destroy_ALREADY_DEFINED
-#else
-#define yylex_destroy xlu__cfg_yylex_destroy
-#endif
-
-#ifdef yyget_debug
-#define xlu__cfg_yyget_debug_ALREADY_DEFINED
-#else
-#define yyget_debug xlu__cfg_yyget_debug
-#endif
-
-#ifdef yyset_debug
-#define xlu__cfg_yyset_debug_ALREADY_DEFINED
-#else
-#define yyset_debug xlu__cfg_yyset_debug
-#endif
-
-#ifdef yyget_extra
-#define xlu__cfg_yyget_extra_ALREADY_DEFINED
-#else
-#define yyget_extra xlu__cfg_yyget_extra
-#endif
-
-#ifdef yyset_extra
-#define xlu__cfg_yyset_extra_ALREADY_DEFINED
-#else
-#define yyset_extra xlu__cfg_yyset_extra
-#endif
-
-#ifdef yyget_in
-#define xlu__cfg_yyget_in_ALREADY_DEFINED
-#else
-#define yyget_in xlu__cfg_yyget_in
-#endif
-
-#ifdef yyset_in
-#define xlu__cfg_yyset_in_ALREADY_DEFINED
-#else
-#define yyset_in xlu__cfg_yyset_in
-#endif
-
-#ifdef yyget_out
-#define xlu__cfg_yyget_out_ALREADY_DEFINED
-#else
-#define yyget_out xlu__cfg_yyget_out
-#endif
-
-#ifdef yyset_out
-#define xlu__cfg_yyset_out_ALREADY_DEFINED
-#else
-#define yyset_out xlu__cfg_yyset_out
-#endif
-
-#ifdef yyget_leng
-#define xlu__cfg_yyget_leng_ALREADY_DEFINED
-#else
-#define yyget_leng xlu__cfg_yyget_leng
-#endif
-
-#ifdef yyget_text
-#define xlu__cfg_yyget_text_ALREADY_DEFINED
-#else
-#define yyget_text xlu__cfg_yyget_text
-#endif
-
-#ifdef yyget_lineno
-#define xlu__cfg_yyget_lineno_ALREADY_DEFINED
-#else
-#define yyget_lineno xlu__cfg_yyget_lineno
-#endif
-
-#ifdef yyset_lineno
-#define xlu__cfg_yyset_lineno_ALREADY_DEFINED
-#else
-#define yyset_lineno xlu__cfg_yyset_lineno
-#endif
-
-#ifdef yyget_column
-#define xlu__cfg_yyget_column_ALREADY_DEFINED
-#else
-#define yyget_column xlu__cfg_yyget_column
-#endif
-
-#ifdef yyset_column
-#define xlu__cfg_yyset_column_ALREADY_DEFINED
-#else
-#define yyset_column xlu__cfg_yyset_column
-#endif
-
-#ifdef yywrap
-#define xlu__cfg_yywrap_ALREADY_DEFINED
-#else
-#define yywrap xlu__cfg_yywrap
-#endif
-
-#ifdef yyget_lval
-#define xlu__cfg_yyget_lval_ALREADY_DEFINED
-#else
-#define yyget_lval xlu__cfg_yyget_lval
-#endif
-
-#ifdef yyset_lval
-#define xlu__cfg_yyset_lval_ALREADY_DEFINED
-#else
-#define yyset_lval xlu__cfg_yyset_lval
-#endif
-
-#ifdef yyget_lloc
-#define xlu__cfg_yyget_lloc_ALREADY_DEFINED
-#else
-#define yyget_lloc xlu__cfg_yyget_lloc
-#endif
-
-#ifdef yyset_lloc
-#define xlu__cfg_yyset_lloc_ALREADY_DEFINED
-#else
-#define yyset_lloc xlu__cfg_yyset_lloc
-#endif
-
-#ifdef yyalloc
-#define xlu__cfg_yyalloc_ALREADY_DEFINED
-#else
-#define yyalloc xlu__cfg_yyalloc
-#endif
-
-#ifdef yyrealloc
-#define xlu__cfg_yyrealloc_ALREADY_DEFINED
-#else
-#define yyrealloc xlu__cfg_yyrealloc
-#endif
-
-#ifdef yyfree
-#define xlu__cfg_yyfree_ALREADY_DEFINED
-#else
-#define yyfree xlu__cfg_yyfree
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#ifndef SIZE_MAX
-#define SIZE_MAX               (~(size_t)0)
-#endif
-
-#endif /* ! C99 */
-
-#endif /* ! FLEXINT_H */
-
-/* begin standard C++ headers. */
-
-/* TODO: this is always defined, so inline it */
-#define yyconst const
-
-#if defined(__GNUC__) && __GNUC__ >= 3
-#define yynoreturn __attribute__((__noreturn__))
-#else
-#define yynoreturn
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an
- *   integer in range [0..255] for use as an array index.
- */
-#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
-
-/* An opaque pointer. */
-#ifndef YY_TYPEDEF_YY_SCANNER_T
-#define YY_TYPEDEF_YY_SCANNER_T
-typedef void* yyscan_t;
-#endif
-
-/* For convenience, these vars (plus the bison vars far below)
-   are macros in the reentrant scanner. */
-#define yyin yyg->yyin_r
-#define yyout yyg->yyout_r
-#define yyextra yyg->yyextra_r
-#define yyleng yyg->yyleng_r
-#define yytext yyg->yytext_r
-#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
-#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
-#define yy_flex_debug yyg->yy_flex_debug_r
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yyg->yy_start = 1 + 2 *
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yyg->yy_start - 1) / 2)
-#define YYSTATE YY_START
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin , yyscanner )
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k.
- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
- * Ditto for the __ia64__ case accordingly.
- */
-#define YY_BUF_SIZE 32768
-#else
-#define YY_BUF_SIZE 16384
-#endif /* __ia64__ */
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-    
-    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
-     *       access to the local variable yy_act. Since yyless() is a macro, it would break
-     *       existing scanners that call yyless() from OUTSIDE yylex.
-     *       One obvious solution it to make yy_act a global. I tried that, and saw
-     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
-     *       normally declared as a register variable-- so it is not worth it.
-     */
-    #define  YY_LESS_LINENO(n) \
-            do { \
-                int yyl;\
-                for ( yyl = n; yyl < yyleng; ++yyl )\
-                    if ( yytext[yyl] == '\n' )\
-                        --yylineno;\
-            }while(0)
-    #define YY_LINENO_REWIND_TO(dst) \
-            do {\
-                const char *p;\
-                for ( p = yy_cp-1; p >= (dst); --p)\
-                    if ( *p == '\n' )\
-                        --yylineno;\
-            }while(0)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = yyg->yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	int yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
-                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
-                          : NULL)
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]
-
-void yyrestart ( FILE *input_file , yyscan_t yyscanner );
-void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
-void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-void yypop_buffer_state ( yyscan_t yyscanner );
-
-static void yyensure_buffer_stack ( yyscan_t yyscanner );
-static void yy_load_buffer_state ( yyscan_t yyscanner );
-static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file , yyscan_t yyscanner );
-#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER , yyscanner)
-
-YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );
-
-void *yyalloc ( yy_size_t , yyscan_t yyscanner );
-void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
-void yyfree ( void * , yyscan_t yyscanner );
-
-#define yy_new_buffer yy_create_buffer
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (yyscanner); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (yyscanner); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-#define xlu__cfg_yywrap(yyscanner) (/*CONSTCOND*/1)
-#define YY_SKIP_YYWRAP
-typedef flex_uint8_t YY_CHAR;
-
-typedef int yy_state_type;
-
-#define yytext_ptr yytext_r
-
-static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
-static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  , yyscan_t yyscanner);
-static int yy_get_next_buffer ( yyscan_t yyscanner );
-static void yynoreturn yy_fatal_error ( const char* msg , yyscan_t yyscanner );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yyg->yytext_ptr = yy_bp; \
-	yyg->yytext_ptr -= yyg->yy_more_len; \
-	yyleng = (int) (yy_cp - yyg->yytext_ptr); \
-	yyg->yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yyg->yy_c_buf_p = yy_cp;
-#define YY_NUM_RULES 17
-#define YY_END_OF_BUFFER 18
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static const flex_int16_t yy_accept[37] =
-    {   0,
-        0,    0,   15,   15,   18,   14,    3,   10,   14,   14,
-       14,   13,   13,    4,    2,    9,    8,    5,    6,    1,
-       15,   15,   16,    0,   12,    0,    0,   10,    0,   11,
-        0,    7,    2,    1,   15,    0
-    } ;
-
-static const YY_CHAR yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    4,    5,    1,    1,    1,    6,    7,
-        7,    1,    8,    9,    7,   10,    1,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,    7,   12,    1,
-       13,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-       14,   15,   16,    1,   17,    1,   18,   18,   18,   18,
-
-       18,   18,   19,   19,   19,   19,   19,   19,   19,   19,
-       19,   19,   19,   19,   19,   19,   19,   19,   19,   18,
-       19,   19,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static const YY_CHAR yy_meta[20] =
-    {   0,
-        1,    2,    3,    1,    1,    1,    1,    1,    1,    4,
-        4,    1,    1,    1,    1,    1,    4,    4,    4
-    } ;
-
-static const flex_int16_t yy_base[43] =
-    {   0,
-        0,    0,   18,   20,   53,   59,   59,   59,   20,   42,
-       19,   59,   19,   59,   15,   59,   59,   59,   59,    0,
-        0,   59,   59,   23,   59,    0,   28,   59,   22,   59,
-        0,   59,   18,    0,    0,   59,   38,   42,   46,   50,
-       26,   54
-    } ;
-
-static const flex_int16_t yy_def[43] =
-    {   0,
-       36,    1,   37,   37,   36,   36,   36,   36,   38,   39,
-       40,   36,   36,   36,   36,   36,   36,   36,   36,   41,
-       42,   36,   36,   38,   36,   38,   39,   36,   40,   36,
-       40,   36,   36,   41,   42,    0,   36,   36,   36,   36,
-       36,   36
-    } ;
-
-static const flex_int16_t yy_nxt[79] =
-    {   0,
-        6,    7,    8,    9,   10,   11,   12,   13,   14,   12,
-       15,   16,   17,   18,    6,   19,    6,   20,   20,   22,
-       23,   22,   23,   25,   30,   33,   25,   30,   33,   34,
-       28,   32,   33,   31,   26,   33,   31,   26,   21,   21,
-       21,   21,   24,   24,   28,   24,   27,   27,   27,   27,
-       29,   29,   36,   29,   35,   36,   36,   35,    5,   36,
-       36,   36,   36,   36,   36,   36,   36,   36,   36,   36,
-       36,   36,   36,   36,   36,   36,   36,   36
-    } ;
-
-static const flex_int16_t yy_chk[79] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    3,
-        3,    4,    4,    9,   11,   15,   24,   29,   33,   41,
-       27,   13,   15,   11,    9,   33,   29,   24,   37,   37,
-       37,   37,   38,   38,   10,   38,   39,   39,   39,   39,
-       40,   40,    5,   40,   42,    0,    0,   42,   36,   36,
-       36,   36,   36,   36,   36,   36,   36,   36,   36,   36,
-       36,   36,   36,   36,   36,   36,   36,   36
-    } ;
-
-/* Table of booleans, true if rule could match eol. */
-static const flex_int32_t yy_rule_can_match_eol[18] =
-    {   0,
-0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,     };
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() (yyg->yy_more_flag = 1)
-#define YY_MORE_ADJ yyg->yy_more_len
-#define YY_RESTORE_YY_MORE_OFFSET
-#line 1 "libxlu_cfg_l.l"
-/* -*- fundamental -*- */
-/*
- * libxlu_cfg_l.l - xl configuration file parsing: lexer
- *
- * Copyright (C) 2010      Citrix Ltd.
- * Author Ian Jackson <ian.jackson@eu.citrix.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published
- * by the Free Software Foundation; version 2.1 only. with the special
- * exception on linking described in file LICENSE.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- */
-#line 20 "libxlu_cfg_l.l"
-#include "libxlu_cfg_i.h"
-
-#define ctx ((CfgParseContext*)yyextra)
-#define YY_NO_INPUT
-
-#define GOT(x) do{                \
-    yylloc->first_line= yylineno; \
-    return (x);                   \
-  }while(0)
-
-/* Some versions of flex have a bug (Fedora bugzilla 612465) which causes
- * it to fail to declare these functions, which it defines.  So declare
- * them ourselves.  Hopefully we won't have to simultaneously support
- * a flex version which declares these differently somehow. */
-int xlu__cfg_yyget_column(yyscan_t yyscanner);
-void xlu__cfg_yyset_column(int  column_no, yyscan_t yyscanner);
-
-#line 740 "libxlu_cfg_l.c"
-
-#line 742 "libxlu_cfg_l.c"
-
-#define INITIAL 0
-#define lexerr 1
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-/* Holds the entire state of the reentrant scanner. */
-struct yyguts_t
-    {
-
-    /* User-defined. Not touched by flex. */
-    YY_EXTRA_TYPE yyextra_r;
-
-    /* The rest are the same as the globals declared in the non-reentrant scanner. */
-    FILE *yyin_r, *yyout_r;
-    size_t yy_buffer_stack_top; /**< index of top of stack. */
-    size_t yy_buffer_stack_max; /**< capacity of stack. */
-    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
-    char yy_hold_char;
-    int yy_n_chars;
-    int yyleng_r;
-    char *yy_c_buf_p;
-    int yy_init;
-    int yy_start;
-    int yy_did_buffer_switch_on_eof;
-    int yy_start_stack_ptr;
-    int yy_start_stack_depth;
-    int *yy_start_stack;
-    yy_state_type yy_last_accepting_state;
-    char* yy_last_accepting_cpos;
-
-    int yylineno_r;
-    int yy_flex_debug_r;
-
-    char *yytext_r;
-    int yy_more_flag;
-    int yy_more_len;
-
-    YYSTYPE * yylval_r;
-
-    YYLTYPE * yylloc_r;
-
-    }; /* end struct yyguts_t */
-
-static int yy_init_globals ( yyscan_t yyscanner );
-
-    /* This must go here because YYSTYPE and YYLTYPE are included
-     * from bison output in section 1.*/
-    #    define yylval yyg->yylval_r
-    
-    #    define yylloc yyg->yylloc_r
-    
-int yylex_init (yyscan_t* scanner);
-
-int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy ( yyscan_t yyscanner );
-
-int yyget_debug ( yyscan_t yyscanner );
-
-void yyset_debug ( int debug_flag , yyscan_t yyscanner );
-
-YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );
-
-void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );
-
-FILE *yyget_in ( yyscan_t yyscanner );
-
-void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );
-
-FILE *yyget_out ( yyscan_t yyscanner );
-
-void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );
-
-			int yyget_leng ( yyscan_t yyscanner );
-
-char *yyget_text ( yyscan_t yyscanner );
-
-int yyget_lineno ( yyscan_t yyscanner );
-
-void yyset_lineno ( int _line_number , yyscan_t yyscanner );
-
-int yyget_column  ( yyscan_t yyscanner );
-
-void yyset_column ( int _column_no , yyscan_t yyscanner );
-
-YYSTYPE * yyget_lval ( yyscan_t yyscanner );
-
-void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
-
-       YYLTYPE *yyget_lloc ( yyscan_t yyscanner );
-    
-        void yyset_lloc ( YYLTYPE * yylloc_param , yyscan_t yyscanner );
-    
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap ( yyscan_t yyscanner );
-#else
-extern int yywrap ( yyscan_t yyscanner );
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-    
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput ( yyscan_t yyscanner );
-#else
-static int input ( yyscan_t yyscanner );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k */
-#define YY_READ_BUF_SIZE 16384
-#else
-#define YY_READ_BUF_SIZE 8192
-#endif /* __ia64__ */
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		int n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex \
-               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner);
-
-#define YY_DECL int yylex \
-               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK /*LINTED*/break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	yy_state_type yy_current_state;
-	char *yy_cp, *yy_bp;
-	int yy_act;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-    yylval = yylval_param;
-
-    yylloc = yylloc_param;
-
-	if ( !yyg->yy_init )
-		{
-		yyg->yy_init = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yyg->yy_start )
-			yyg->yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack (yyscanner);
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
-		}
-
-		yy_load_buffer_state( yyscanner );
-		}
-
-	{
-#line 53 "libxlu_cfg_l.l"
-
-
-#line 1028 "libxlu_cfg_l.c"
-
-	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
-		{
-		yyg->yy_more_len = 0;
-		if ( yyg->yy_more_flag )
-			{
-			yyg->yy_more_len = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
-			yyg->yy_more_flag = 0;
-			}
-		yy_cp = yyg->yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yyg->yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yyg->yy_start;
-yy_match:
-		do
-			{
-			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
-			if ( yy_accept[yy_current_state] )
-				{
-				yyg->yy_last_accepting_state = yy_current_state;
-				yyg->yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 37 )
-					yy_c = yy_meta[yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-			++yy_cp;
-			}
-		while ( yy_current_state != 36 );
-		yy_cp = yyg->yy_last_accepting_cpos;
-		yy_current_state = yyg->yy_last_accepting_state;
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-
-		YY_DO_BEFORE_ACTION;
-
-		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
-			{
-			int yyl;
-			for ( yyl = yyg->yy_more_len; yyl < yyleng; ++yyl )
-				if ( yytext[yyl] == '\n' )
-					
-    do{ yylineno++;
-        yycolumn=0;
-    }while(0)
-;
-			}
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yyg->yy_hold_char;
-			yy_cp = yyg->yy_last_accepting_cpos;
-			yy_current_state = yyg->yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 55 "libxlu_cfg_l.l"
-{
-                          yylval->string= xlu__cfgl_strdup(ctx,yytext);
-                          GOT(IDENT);
-                        }
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 59 "libxlu_cfg_l.l"
-{
-                          yylval->string= xlu__cfgl_strdup(ctx,yytext);
-                          GOT(NUMBER);
-                        }
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 64 "libxlu_cfg_l.l"
-
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 66 "libxlu_cfg_l.l"
-{ GOT(','); }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 67 "libxlu_cfg_l.l"
-{ GOT('['); }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 68 "libxlu_cfg_l.l"
-{ GOT(']'); }
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 69 "libxlu_cfg_l.l"
-{ GOT(OP_ADD); }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 70 "libxlu_cfg_l.l"
-{ GOT('='); }
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 71 "libxlu_cfg_l.l"
-{ GOT(';'); }
-	YY_BREAK
-case 10:
-/* rule 10 can match eol */
-YY_RULE_SETUP
-#line 73 "libxlu_cfg_l.l"
-{ yylloc->first_line= yylineno-1; return NEWLINE; }
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 75 "libxlu_cfg_l.l"
-{
-                          yylval->string= xlu__cfgl_dequote(ctx,yytext);
-                          GOT(STRING);
-                        }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 79 "libxlu_cfg_l.l"
-{
-                          yylval->string= xlu__cfgl_dequote(ctx,yytext);
-                          GOT(STRING);
-                        }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 84 "libxlu_cfg_l.l"
-{
-                          ctx->likely_python= 1;
-                          BEGIN(lexerr);
-                          yymore();
-                        }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 90 "libxlu_cfg_l.l"
-{
-                          BEGIN(lexerr);
-                          yymore();
-                        }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 95 "libxlu_cfg_l.l"
-{
-                          xlu__cfgl_lexicalerror(ctx,"lexical error");
-                          BEGIN(0);
-                        }
-	YY_BREAK
-case 16:
-/* rule 16 can match eol */
-YY_RULE_SETUP
-#line 100 "libxlu_cfg_l.l"
-{
-                          xlu__cfgl_lexicalerror(ctx,"lexical error");
-                          BEGIN(0);
-                          GOT(NEWLINE);
-                        }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 105 "libxlu_cfg_l.l"
-YY_FATAL_ERROR( "flex scanner jammed" );
-	YY_BREAK
-#line 1212 "libxlu_cfg_l.c"
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(lexerr):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yyg->yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state( yyscanner );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);
-
-			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yyg->yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yyg->yy_last_accepting_cpos;
-				yy_current_state = yyg->yy_last_accepting_state;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer( yyscanner ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yyg->yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap( yyscanner ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yyg->yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yyg->yy_c_buf_p =
-					yyg->yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state( yyscanner );
-
-				yy_cp = yyg->yy_c_buf_p;
-				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yyg->yy_c_buf_p =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];
-
-				yy_current_state = yy_get_previous_state( yyscanner );
-
-				yy_cp = yyg->yy_c_buf_p;
-				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of user's declarations */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	char *source = yyg->yytext_ptr;
-	int number_to_move, i;
-	int ret_val;
-
-	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;
-
-	else
-		{
-			int num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
-
-			int yy_c_buf_p_offset =
-				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc( (void *) b->yy_ch_buf,
-							 (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = NULL;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			yyg->yy_n_chars, num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
-		}
-
-	if ( yyg->yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin  , yyscanner);
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
-			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-		/* "- 2" to take care of EOB's */
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
-	}
-
-	yyg->yy_n_chars += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
-{
-	yy_state_type yy_current_state;
-	char *yy_cp;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	yy_current_state = yyg->yy_start;
-
-	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
-		{
-		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yyg->yy_last_accepting_state = yy_current_state;
-			yyg->yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 37 )
-				yy_c = yy_meta[yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
-{
-	int yy_is_jam;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
-	char *yy_cp = yyg->yy_c_buf_p;
-
-	YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yyg->yy_last_accepting_state = yy_current_state;
-		yyg->yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 37 )
-			yy_c = yy_meta[yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-	yy_is_jam = (yy_current_state == 36);
-
-	(void)yyg;
-	return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_UNPUT
-
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (yyscan_t yyscanner)
-#else
-    static int input  (yyscan_t yyscanner)
-#endif
-
-{
-	int c;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	*yyg->yy_c_buf_p = yyg->yy_hold_char;
-
-	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
-			/* This was really a NUL. */
-			*yyg->yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
-			++yyg->yy_c_buf_p;
-
-			switch ( yy_get_next_buffer( yyscanner ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin , yyscanner);
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap( yyscanner ) )
-						return 0;
-
-					if ( ! yyg->yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput(yyscanner);
-#else
-					return input(yyscanner);
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
-	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
-	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
-
-	if ( c == '\n' )
-		
-    do{ yylineno++;
-        yycolumn=0;
-    }while(0)
-;
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * @param yyscanner The scanner object.
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack (yyscanner);
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
-	}
-
-	yy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);
-	yy_load_buffer_state( yyscanner );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * @param yyscanner The scanner object.
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack (yyscanner);
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*yyg->yy_c_buf_p = yyg->yy_hold_char;
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( yyscanner );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yyg->yy_did_buffer_switch_on_eof = 1;
-}
-
-static void yy_load_buffer_state  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	yyg->yy_hold_char = *yyg->yy_c_buf_p;
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * @param yyscanner The scanner object.
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file , yyscanner);
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * @param yyscanner The scanner object.
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree( (void *) b->yy_ch_buf , yyscanner );
-
-	yyfree( (void *) b , yyscanner );
-}
-
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)
-
-{
-	int oerrno = errno;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	yy_flush_buffer( b , yyscanner);
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * @param yyscanner The scanner object.
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( yyscanner );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  @param yyscanner The scanner object.
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack(yyscanner);
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*yyg->yy_c_buf_p = yyg->yy_hold_char;
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		yyg->yy_buffer_stack_top++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( yyscanner );
-	yyg->yy_did_buffer_switch_on_eof = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  @param yyscanner The scanner object.
- */
-void yypop_buffer_state (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if (yyg->yy_buffer_stack_top > 0)
-		--yyg->yy_buffer_stack_top;
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( yyscanner );
-		yyg->yy_did_buffer_switch_on_eof = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (yyscan_t yyscanner)
-{
-	yy_size_t num_to_alloc;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if (!yyg->yy_buffer_stack) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
-		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								, yyscanner);
-		if ( ! yyg->yy_buffer_stack )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-
-		yyg->yy_buffer_stack_max = num_to_alloc;
-		yyg->yy_buffer_stack_top = 0;
-		return;
-	}
-
-	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		yy_size_t grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
-		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
-								(yyg->yy_buffer_stack,
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								, yyscanner);
-		if ( ! yyg->yy_buffer_stack )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
-		yyg->yy_buffer_stack_max = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return NULL;
-
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = NULL;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b , yyscanner );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
-{
-    
-	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param yybytes the byte buffer to scan
- * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
- * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = (yy_size_t) (_yybytes_len + 2);
-	buf = (char *) yyalloc( n , yyscanner );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n , yyscanner);
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-	fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = yyg->yy_hold_char; \
-		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
-		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
-		*yyg->yy_c_buf_p = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the user-defined data for this scanner.
- * @param yyscanner The scanner object.
- */
-YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyextra;
-}
-
-/** Get the current line number.
- * @param yyscanner The scanner object.
- */
-int yyget_lineno  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        if (! YY_CURRENT_BUFFER)
-            return 0;
-    
-    return yylineno;
-}
-
-/** Get the current column number.
- * @param yyscanner The scanner object.
- */
-int yyget_column  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        if (! YY_CURRENT_BUFFER)
-            return 0;
-    
-    return yycolumn;
-}
-
-/** Get the input stream.
- * @param yyscanner The scanner object.
- */
-FILE *yyget_in  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyin;
-}
-
-/** Get the output stream.
- * @param yyscanner The scanner object.
- */
-FILE *yyget_out  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyout;
-}
-
-/** Get the length of the current token.
- * @param yyscanner The scanner object.
- */
-int yyget_leng  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyleng;
-}
-
-/** Get the current token.
- * @param yyscanner The scanner object.
- */
-
-char *yyget_text  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yytext;
-}
-
-/** Set the user-defined data. This data is never touched by the scanner.
- * @param user_defined The data to be associated with this scanner.
- * @param yyscanner The scanner object.
- */
-void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyextra = user_defined ;
-}
-
-/** Set the current line number.
- * @param _line_number line number
- * @param yyscanner The scanner object.
- */
-void yyset_lineno (int  _line_number , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        /* lineno is only valid if an input buffer exists. */
-        if (! YY_CURRENT_BUFFER )
-           YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
-    
-    yylineno = _line_number;
-}
-
-/** Set the current column.
- * @param _column_no column number
- * @param yyscanner The scanner object.
- */
-void yyset_column (int  _column_no , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        /* column is only valid if an input buffer exists. */
-        if (! YY_CURRENT_BUFFER )
-           YY_FATAL_ERROR( "yyset_column called with no buffer" );
-    
-    yycolumn = _column_no;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param _in_str A readable stream.
- * @param yyscanner The scanner object.
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  _in_str , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyin = _in_str ;
-}
-
-void yyset_out (FILE *  _out_str , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyout = _out_str ;
-}
-
-int yyget_debug  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yy_flex_debug;
-}
-
-void yyset_debug (int  _bdebug , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yy_flex_debug = _bdebug ;
-}
-
-/* Accessor methods for yylval and yylloc */
-
-YYSTYPE * yyget_lval  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yylval;
-}
-
-void yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yylval = yylval_param;
-}
-
-YYLTYPE *yyget_lloc  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yylloc;
-}
-    
-void yyset_lloc (YYLTYPE *  yylloc_param , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yylloc = yylloc_param;
-}
-    
-/* User-visible API */
-
-/* yylex_init is special because it creates the scanner itself, so it is
- * the ONLY reentrant function that doesn't take the scanner as the last argument.
- * That's why we explicitly handle the declaration, instead of using our macros.
- */
-int yylex_init(yyscan_t* ptr_yy_globals)
-{
-    if (ptr_yy_globals == NULL){
-        errno = EINVAL;
-        return 1;
-    }
-
-    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );
-
-    if (*ptr_yy_globals == NULL){
-        errno = ENOMEM;
-        return 1;
-    }
-
-    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
-    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-
-    return yy_init_globals ( *ptr_yy_globals );
-}
-
-/* yylex_init_extra has the same functionality as yylex_init, but follows the
- * convention of taking the scanner as the last argument. Note however, that
- * this is a *pointer* to a scanner, as it will be allocated by this call (and
- * is the reason, too, why this function also must handle its own declaration).
- * The user defined value in the first argument will be available to yyalloc in
- * the yyextra field.
- */
-int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )
-{
-    struct yyguts_t dummy_yyguts;
-
-    yyset_extra (yy_user_defined, &dummy_yyguts);
-
-    if (ptr_yy_globals == NULL){
-        errno = EINVAL;
-        return 1;
-    }
-
-    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-
-    if (*ptr_yy_globals == NULL){
-        errno = ENOMEM;
-        return 1;
-    }
-
-    /* By setting to 0xAA, we expose bugs in
-    yy_init_globals. Leave at 0x00 for releases. */
-    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-
-    yyset_extra (yy_user_defined, *ptr_yy_globals);
-
-    return yy_init_globals ( *ptr_yy_globals );
-}
-
-static int yy_init_globals (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    yyg->yy_buffer_stack = NULL;
-    yyg->yy_buffer_stack_top = 0;
-    yyg->yy_buffer_stack_max = 0;
-    yyg->yy_c_buf_p = NULL;
-    yyg->yy_init = 0;
-    yyg->yy_start = 0;
-
-    yyg->yy_start_stack_ptr = 0;
-    yyg->yy_start_stack_depth = 0;
-    yyg->yy_start_stack =  NULL;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = NULL;
-    yyout = NULL;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state(yyscanner);
-	}
-
-	/* Destroy the stack itself. */
-	yyfree(yyg->yy_buffer_stack , yyscanner);
-	yyg->yy_buffer_stack = NULL;
-
-    /* Destroy the start condition stack. */
-        yyfree( yyg->yy_start_stack , yyscanner );
-        yyg->yy_start_stack = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( yyscanner);
-
-    /* Destroy the main struct (reentrant only). */
-    yyfree ( yyscanner , yyscanner );
-    yyscanner = NULL;
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-
-	int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
-{
-	int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-	return malloc(size);
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return realloc(ptr, size);
-}
-
-void yyfree (void * ptr , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 105 "libxlu_cfg_l.l"
diff --git a/tools/libs/util/libxlu_cfg_l.h b/tools/libs/util/libxlu_cfg_l.h
deleted file mode 100644
index 213ba18b86..0000000000
--- a/tools/libs/util/libxlu_cfg_l.h
+++ /dev/null
@@ -1,734 +0,0 @@
-#ifndef xlu__cfg_yyHEADER_H
-#define xlu__cfg_yyHEADER_H 1
-#define xlu__cfg_yyIN_HEADER 1
-
-#line 6 "libxlu_cfg_l.h"
-
-#line 8 "libxlu_cfg_l.h"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 4
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-#ifdef yy_create_buffer
-#define xlu__cfg_yy_create_buffer_ALREADY_DEFINED
-#else
-#define yy_create_buffer xlu__cfg_yy_create_buffer
-#endif
-
-#ifdef yy_delete_buffer
-#define xlu__cfg_yy_delete_buffer_ALREADY_DEFINED
-#else
-#define yy_delete_buffer xlu__cfg_yy_delete_buffer
-#endif
-
-#ifdef yy_scan_buffer
-#define xlu__cfg_yy_scan_buffer_ALREADY_DEFINED
-#else
-#define yy_scan_buffer xlu__cfg_yy_scan_buffer
-#endif
-
-#ifdef yy_scan_string
-#define xlu__cfg_yy_scan_string_ALREADY_DEFINED
-#else
-#define yy_scan_string xlu__cfg_yy_scan_string
-#endif
-
-#ifdef yy_scan_bytes
-#define xlu__cfg_yy_scan_bytes_ALREADY_DEFINED
-#else
-#define yy_scan_bytes xlu__cfg_yy_scan_bytes
-#endif
-
-#ifdef yy_init_buffer
-#define xlu__cfg_yy_init_buffer_ALREADY_DEFINED
-#else
-#define yy_init_buffer xlu__cfg_yy_init_buffer
-#endif
-
-#ifdef yy_flush_buffer
-#define xlu__cfg_yy_flush_buffer_ALREADY_DEFINED
-#else
-#define yy_flush_buffer xlu__cfg_yy_flush_buffer
-#endif
-
-#ifdef yy_load_buffer_state
-#define xlu__cfg_yy_load_buffer_state_ALREADY_DEFINED
-#else
-#define yy_load_buffer_state xlu__cfg_yy_load_buffer_state
-#endif
-
-#ifdef yy_switch_to_buffer
-#define xlu__cfg_yy_switch_to_buffer_ALREADY_DEFINED
-#else
-#define yy_switch_to_buffer xlu__cfg_yy_switch_to_buffer
-#endif
-
-#ifdef yypush_buffer_state
-#define xlu__cfg_yypush_buffer_state_ALREADY_DEFINED
-#else
-#define yypush_buffer_state xlu__cfg_yypush_buffer_state
-#endif
-
-#ifdef yypop_buffer_state
-#define xlu__cfg_yypop_buffer_state_ALREADY_DEFINED
-#else
-#define yypop_buffer_state xlu__cfg_yypop_buffer_state
-#endif
-
-#ifdef yyensure_buffer_stack
-#define xlu__cfg_yyensure_buffer_stack_ALREADY_DEFINED
-#else
-#define yyensure_buffer_stack xlu__cfg_yyensure_buffer_stack
-#endif
-
-#ifdef yylex
-#define xlu__cfg_yylex_ALREADY_DEFINED
-#else
-#define yylex xlu__cfg_yylex
-#endif
-
-#ifdef yyrestart
-#define xlu__cfg_yyrestart_ALREADY_DEFINED
-#else
-#define yyrestart xlu__cfg_yyrestart
-#endif
-
-#ifdef yylex_init
-#define xlu__cfg_yylex_init_ALREADY_DEFINED
-#else
-#define yylex_init xlu__cfg_yylex_init
-#endif
-
-#ifdef yylex_init_extra
-#define xlu__cfg_yylex_init_extra_ALREADY_DEFINED
-#else
-#define yylex_init_extra xlu__cfg_yylex_init_extra
-#endif
-
-#ifdef yylex_destroy
-#define xlu__cfg_yylex_destroy_ALREADY_DEFINED
-#else
-#define yylex_destroy xlu__cfg_yylex_destroy
-#endif
-
-#ifdef yyget_debug
-#define xlu__cfg_yyget_debug_ALREADY_DEFINED
-#else
-#define yyget_debug xlu__cfg_yyget_debug
-#endif
-
-#ifdef yyset_debug
-#define xlu__cfg_yyset_debug_ALREADY_DEFINED
-#else
-#define yyset_debug xlu__cfg_yyset_debug
-#endif
-
-#ifdef yyget_extra
-#define xlu__cfg_yyget_extra_ALREADY_DEFINED
-#else
-#define yyget_extra xlu__cfg_yyget_extra
-#endif
-
-#ifdef yyset_extra
-#define xlu__cfg_yyset_extra_ALREADY_DEFINED
-#else
-#define yyset_extra xlu__cfg_yyset_extra
-#endif
-
-#ifdef yyget_in
-#define xlu__cfg_yyget_in_ALREADY_DEFINED
-#else
-#define yyget_in xlu__cfg_yyget_in
-#endif
-
-#ifdef yyset_in
-#define xlu__cfg_yyset_in_ALREADY_DEFINED
-#else
-#define yyset_in xlu__cfg_yyset_in
-#endif
-
-#ifdef yyget_out
-#define xlu__cfg_yyget_out_ALREADY_DEFINED
-#else
-#define yyget_out xlu__cfg_yyget_out
-#endif
-
-#ifdef yyset_out
-#define xlu__cfg_yyset_out_ALREADY_DEFINED
-#else
-#define yyset_out xlu__cfg_yyset_out
-#endif
-
-#ifdef yyget_leng
-#define xlu__cfg_yyget_leng_ALREADY_DEFINED
-#else
-#define yyget_leng xlu__cfg_yyget_leng
-#endif
-
-#ifdef yyget_text
-#define xlu__cfg_yyget_text_ALREADY_DEFINED
-#else
-#define yyget_text xlu__cfg_yyget_text
-#endif
-
-#ifdef yyget_lineno
-#define xlu__cfg_yyget_lineno_ALREADY_DEFINED
-#else
-#define yyget_lineno xlu__cfg_yyget_lineno
-#endif
-
-#ifdef yyset_lineno
-#define xlu__cfg_yyset_lineno_ALREADY_DEFINED
-#else
-#define yyset_lineno xlu__cfg_yyset_lineno
-#endif
-
-#ifdef yyget_column
-#define xlu__cfg_yyget_column_ALREADY_DEFINED
-#else
-#define yyget_column xlu__cfg_yyget_column
-#endif
-
-#ifdef yyset_column
-#define xlu__cfg_yyset_column_ALREADY_DEFINED
-#else
-#define yyset_column xlu__cfg_yyset_column
-#endif
-
-#ifdef yywrap
-#define xlu__cfg_yywrap_ALREADY_DEFINED
-#else
-#define yywrap xlu__cfg_yywrap
-#endif
-
-#ifdef yyget_lval
-#define xlu__cfg_yyget_lval_ALREADY_DEFINED
-#else
-#define yyget_lval xlu__cfg_yyget_lval
-#endif
-
-#ifdef yyset_lval
-#define xlu__cfg_yyset_lval_ALREADY_DEFINED
-#else
-#define yyset_lval xlu__cfg_yyset_lval
-#endif
-
-#ifdef yyget_lloc
-#define xlu__cfg_yyget_lloc_ALREADY_DEFINED
-#else
-#define yyget_lloc xlu__cfg_yyget_lloc
-#endif
-
-#ifdef yyset_lloc
-#define xlu__cfg_yyset_lloc_ALREADY_DEFINED
-#else
-#define yyset_lloc xlu__cfg_yyset_lloc
-#endif
-
-#ifdef yyalloc
-#define xlu__cfg_yyalloc_ALREADY_DEFINED
-#else
-#define yyalloc xlu__cfg_yyalloc
-#endif
-
-#ifdef yyrealloc
-#define xlu__cfg_yyrealloc_ALREADY_DEFINED
-#else
-#define yyrealloc xlu__cfg_yyrealloc
-#endif
-
-#ifdef yyfree
-#define xlu__cfg_yyfree_ALREADY_DEFINED
-#else
-#define yyfree xlu__cfg_yyfree
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#ifndef SIZE_MAX
-#define SIZE_MAX               (~(size_t)0)
-#endif
-
-#endif /* ! C99 */
-
-#endif /* ! FLEXINT_H */
-
-/* begin standard C++ headers. */
-
-/* TODO: this is always defined, so inline it */
-#define yyconst const
-
-#if defined(__GNUC__) && __GNUC__ >= 3
-#define yynoreturn __attribute__((__noreturn__))
-#else
-#define yynoreturn
-#endif
-
-/* An opaque pointer. */
-#ifndef YY_TYPEDEF_YY_SCANNER_T
-#define YY_TYPEDEF_YY_SCANNER_T
-typedef void* yyscan_t;
-#endif
-
-/* For convenience, these vars (plus the bison vars far below)
-   are macros in the reentrant scanner. */
-#define yyin yyg->yyin_r
-#define yyout yyg->yyout_r
-#define yyextra yyg->yyextra_r
-#define yyleng yyg->yyleng_r
-#define yytext yyg->yytext_r
-#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
-#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
-#define yy_flex_debug yyg->yy_flex_debug_r
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k.
- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
- * Ditto for the __ia64__ case accordingly.
- */
-#define YY_BUF_SIZE 32768
-#else
-#define YY_BUF_SIZE 16384
-#endif /* __ia64__ */
-#endif
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	int yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-void yyrestart ( FILE *input_file , yyscan_t yyscanner );
-void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
-void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-void yypop_buffer_state ( yyscan_t yyscanner );
-
-YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );
-
-void *yyalloc ( yy_size_t , yyscan_t yyscanner );
-void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
-void yyfree ( void * , yyscan_t yyscanner );
-
-#define xlu__cfg_yywrap(yyscanner) (/*CONSTCOND*/1)
-#define YY_SKIP_YYWRAP
-
-#define yytext_ptr yytext_r
-
-#ifdef YY_HEADER_EXPORT_START_CONDITIONS
-#define INITIAL 0
-#define lexerr 1
-
-#endif
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-int yylex_init (yyscan_t* scanner);
-
-int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy ( yyscan_t yyscanner );
-
-int yyget_debug ( yyscan_t yyscanner );
-
-void yyset_debug ( int debug_flag , yyscan_t yyscanner );
-
-YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );
-
-void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );
-
-FILE *yyget_in ( yyscan_t yyscanner );
-
-void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );
-
-FILE *yyget_out ( yyscan_t yyscanner );
-
-void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );
-
-			int yyget_leng ( yyscan_t yyscanner );
-
-char *yyget_text ( yyscan_t yyscanner );
-
-int yyget_lineno ( yyscan_t yyscanner );
-
-void yyset_lineno ( int _line_number , yyscan_t yyscanner );
-
-int yyget_column  ( yyscan_t yyscanner );
-
-void yyset_column ( int _column_no , yyscan_t yyscanner );
-
-YYSTYPE * yyget_lval ( yyscan_t yyscanner );
-
-void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
-
-       YYLTYPE *yyget_lloc ( yyscan_t yyscanner );
-    
-        void yyset_lloc ( YYLTYPE * yylloc_param , yyscan_t yyscanner );
-    
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap ( yyscan_t yyscanner );
-#else
-extern int yywrap ( yyscan_t yyscanner );
-#endif
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
-#endif
-
-#ifndef YY_NO_INPUT
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k */
-#define YY_READ_BUF_SIZE 16384
-#else
-#define YY_READ_BUF_SIZE 8192
-#endif /* __ia64__ */
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex \
-               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner);
-
-#define YY_DECL int yylex \
-               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
-#endif /* !YY_DECL */
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-#undef YY_NEW_FILE
-#undef YY_FLUSH_BUFFER
-#undef yy_set_bol
-#undef yy_new_buffer
-#undef yy_set_interactive
-#undef YY_DO_BEFORE_ACTION
-
-#ifdef YY_DECL_IS_OURS
-#undef YY_DECL_IS_OURS
-#undef YY_DECL
-#endif
-
-#ifndef xlu__cfg_yy_create_buffer_ALREADY_DEFINED
-#undef yy_create_buffer
-#endif
-#ifndef xlu__cfg_yy_delete_buffer_ALREADY_DEFINED
-#undef yy_delete_buffer
-#endif
-#ifndef xlu__cfg_yy_scan_buffer_ALREADY_DEFINED
-#undef yy_scan_buffer
-#endif
-#ifndef xlu__cfg_yy_scan_string_ALREADY_DEFINED
-#undef yy_scan_string
-#endif
-#ifndef xlu__cfg_yy_scan_bytes_ALREADY_DEFINED
-#undef yy_scan_bytes
-#endif
-#ifndef xlu__cfg_yy_init_buffer_ALREADY_DEFINED
-#undef yy_init_buffer
-#endif
-#ifndef xlu__cfg_yy_flush_buffer_ALREADY_DEFINED
-#undef yy_flush_buffer
-#endif
-#ifndef xlu__cfg_yy_load_buffer_state_ALREADY_DEFINED
-#undef yy_load_buffer_state
-#endif
-#ifndef xlu__cfg_yy_switch_to_buffer_ALREADY_DEFINED
-#undef yy_switch_to_buffer
-#endif
-#ifndef xlu__cfg_yypush_buffer_state_ALREADY_DEFINED
-#undef yypush_buffer_state
-#endif
-#ifndef xlu__cfg_yypop_buffer_state_ALREADY_DEFINED
-#undef yypop_buffer_state
-#endif
-#ifndef xlu__cfg_yyensure_buffer_stack_ALREADY_DEFINED
-#undef yyensure_buffer_stack
-#endif
-#ifndef xlu__cfg_yylex_ALREADY_DEFINED
-#undef yylex
-#endif
-#ifndef xlu__cfg_yyrestart_ALREADY_DEFINED
-#undef yyrestart
-#endif
-#ifndef xlu__cfg_yylex_init_ALREADY_DEFINED
-#undef yylex_init
-#endif
-#ifndef xlu__cfg_yylex_init_extra_ALREADY_DEFINED
-#undef yylex_init_extra
-#endif
-#ifndef xlu__cfg_yylex_destroy_ALREADY_DEFINED
-#undef yylex_destroy
-#endif
-#ifndef xlu__cfg_yyget_debug_ALREADY_DEFINED
-#undef yyget_debug
-#endif
-#ifndef xlu__cfg_yyset_debug_ALREADY_DEFINED
-#undef yyset_debug
-#endif
-#ifndef xlu__cfg_yyget_extra_ALREADY_DEFINED
-#undef yyget_extra
-#endif
-#ifndef xlu__cfg_yyset_extra_ALREADY_DEFINED
-#undef yyset_extra
-#endif
-#ifndef xlu__cfg_yyget_in_ALREADY_DEFINED
-#undef yyget_in
-#endif
-#ifndef xlu__cfg_yyset_in_ALREADY_DEFINED
-#undef yyset_in
-#endif
-#ifndef xlu__cfg_yyget_out_ALREADY_DEFINED
-#undef yyget_out
-#endif
-#ifndef xlu__cfg_yyset_out_ALREADY_DEFINED
-#undef yyset_out
-#endif
-#ifndef xlu__cfg_yyget_leng_ALREADY_DEFINED
-#undef yyget_leng
-#endif
-#ifndef xlu__cfg_yyget_text_ALREADY_DEFINED
-#undef yyget_text
-#endif
-#ifndef xlu__cfg_yyget_lineno_ALREADY_DEFINED
-#undef yyget_lineno
-#endif
-#ifndef xlu__cfg_yyset_lineno_ALREADY_DEFINED
-#undef yyset_lineno
-#endif
-#ifndef xlu__cfg_yyget_column_ALREADY_DEFINED
-#undef yyget_column
-#endif
-#ifndef xlu__cfg_yyset_column_ALREADY_DEFINED
-#undef yyset_column
-#endif
-#ifndef xlu__cfg_yywrap_ALREADY_DEFINED
-#undef yywrap
-#endif
-#ifndef xlu__cfg_yyget_lval_ALREADY_DEFINED
-#undef yyget_lval
-#endif
-#ifndef xlu__cfg_yyset_lval_ALREADY_DEFINED
-#undef yyset_lval
-#endif
-#ifndef xlu__cfg_yyget_lloc_ALREADY_DEFINED
-#undef yyget_lloc
-#endif
-#ifndef xlu__cfg_yyset_lloc_ALREADY_DEFINED
-#undef yyset_lloc
-#endif
-#ifndef xlu__cfg_yyalloc_ALREADY_DEFINED
-#undef yyalloc
-#endif
-#ifndef xlu__cfg_yyrealloc_ALREADY_DEFINED
-#undef yyrealloc
-#endif
-#ifndef xlu__cfg_yyfree_ALREADY_DEFINED
-#undef yyfree
-#endif
-#ifndef xlu__cfg_yytext_ALREADY_DEFINED
-#undef yytext
-#endif
-#ifndef xlu__cfg_yyleng_ALREADY_DEFINED
-#undef yyleng
-#endif
-#ifndef xlu__cfg_yyin_ALREADY_DEFINED
-#undef yyin
-#endif
-#ifndef xlu__cfg_yyout_ALREADY_DEFINED
-#undef yyout
-#endif
-#ifndef xlu__cfg_yy_flex_debug_ALREADY_DEFINED
-#undef yy_flex_debug
-#endif
-#ifndef xlu__cfg_yylineno_ALREADY_DEFINED
-#undef yylineno
-#endif
-#ifndef xlu__cfg_yytables_fload_ALREADY_DEFINED
-#undef yytables_fload
-#endif
-#ifndef xlu__cfg_yytables_destroy_ALREADY_DEFINED
-#undef yytables_destroy
-#endif
-#ifndef xlu__cfg_yyTABLES_NAME_ALREADY_DEFINED
-#undef yyTABLES_NAME
-#endif
-
-#line 105 "libxlu_cfg_l.l"
-
-#line 733 "libxlu_cfg_l.h"
-#undef xlu__cfg_yyIN_HEADER
-#endif /* xlu__cfg_yyHEADER_H */
diff --git a/tools/libs/util/libxlu_cfg_y.c b/tools/libs/util/libxlu_cfg_y.c
deleted file mode 100644
index 6d4638afc9..0000000000
--- a/tools/libs/util/libxlu_cfg_y.c
+++ /dev/null
@@ -1,1705 +0,0 @@
-/* A Bison parser, made by GNU Bison 3.3.2.  */
-
-/* Bison implementation for Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
-   Inc.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
-
-/* C LALR(1) parser skeleton written by Richard Stallman, by
-   simplifying the original so-called "semantic" parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Undocumented macros, especially those whose name start with YY_,
-   are private implementation details.  Do not rely on them.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Bison version.  */
-#define YYBISON_VERSION "3.3.2"
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 1
-
-/* Push parsers.  */
-#define YYPUSH 0
-
-/* Pull parsers.  */
-#define YYPULL 1
-
-
-/* Substitute the variable and function names.  */
-#define yyparse         xlu__cfg_yyparse
-#define yylex           xlu__cfg_yylex
-#define yyerror         xlu__cfg_yyerror
-#define yydebug         xlu__cfg_yydebug
-#define yynerrs         xlu__cfg_yynerrs
-
-
-/* First part of user prologue.  */
-#line 19 "libxlu_cfg_y.y" /* yacc.c:337  */
-
-#define ctx_scanner ctx->scanner
-#include "libxlu_cfg_i.h"
-#include "libxlu_cfg_l.h"
-
-#line 82 "libxlu_cfg_y.c" /* yacc.c:337  */
-# ifndef YY_NULLPTR
-#  if defined __cplusplus
-#   if 201103L <= __cplusplus
-#    define YY_NULLPTR nullptr
-#   else
-#    define YY_NULLPTR 0
-#   endif
-#  else
-#   define YY_NULLPTR ((void*)0)
-#  endif
-# endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 1
-#endif
-
-/* In a future release of Bison, this section will be replaced
-   by #include "libxlu_cfg_y.h".  */
-#ifndef YY_XLU_CFG_YY_LIBXLU_CFG_Y_H_INCLUDED
-# define YY_XLU_CFG_YY_LIBXLU_CFG_Y_H_INCLUDED
-/* Debug traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-#if YYDEBUG
-extern int xlu__cfg_yydebug;
-#endif
-
-/* Token type.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-  enum yytokentype
-  {
-    IDENT = 258,
-    STRING = 259,
-    NUMBER = 260,
-    NEWLINE = 261,
-    OP_ADD = 262
-  };
-#endif
-
-/* Value type.  */
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-
-union YYSTYPE
-{
-#line 25 "libxlu_cfg_y.y" /* yacc.c:352  */
-
-  char *string;
-  XLU_ConfigValue *value;
-
-#line 138 "libxlu_cfg_y.c" /* yacc.c:352  */
-};
-
-typedef union YYSTYPE YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-/* Location type.  */
-#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
-typedef struct YYLTYPE YYLTYPE;
-struct YYLTYPE
-{
-  int first_line;
-  int first_column;
-  int last_line;
-  int last_column;
-};
-# define YYLTYPE_IS_DECLARED 1
-# define YYLTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-int xlu__cfg_yyparse (CfgParseContext *ctx);
-
-#endif /* !YY_XLU_CFG_YY_LIBXLU_CFG_Y_H_INCLUDED  */
-
-
-
-#ifdef short
-# undef short
-#endif
-
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
-#endif
-
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
-#else
-typedef signed char yytype_int8;
-#endif
-
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
-#else
-typedef unsigned short yytype_uint16;
-#endif
-
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
-#else
-typedef short yytype_int16;
-#endif
-
-#ifndef YYSIZE_T
-# ifdef __SIZE_TYPE__
-#  define YYSIZE_T __SIZE_TYPE__
-# elif defined size_t
-#  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# else
-#  define YYSIZE_T unsigned
-# endif
-#endif
-
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
-
-#ifndef YY_
-# if defined YYENABLE_NLS && YYENABLE_NLS
-#  if ENABLE_NLS
-#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
-#  endif
-# endif
-# ifndef YY_
-#  define YY_(Msgid) Msgid
-# endif
-#endif
-
-#ifndef YY_ATTRIBUTE
-# if (defined __GNUC__                                               \
-      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
-     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
-#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
-# else
-#  define YY_ATTRIBUTE(Spec) /* empty */
-# endif
-#endif
-
-#ifndef YY_ATTRIBUTE_PURE
-# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
-#endif
-
-#ifndef YY_ATTRIBUTE_UNUSED
-# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
-#endif
-
-/* Suppress unused-variable warnings by "using" E.  */
-#if ! defined lint || defined __GNUC__
-# define YYUSE(E) ((void) (E))
-#else
-# define YYUSE(E) /* empty */
-#endif
-
-#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
-/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
-    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
-    _Pragma ("GCC diagnostic pop")
-#else
-# define YY_INITIAL_VALUE(Value) Value
-#endif
-#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END
-#endif
-#ifndef YY_INITIAL_VALUE
-# define YY_INITIAL_VALUE(Value) /* Nothing. */
-#endif
-
-
-#if ! defined yyoverflow || YYERROR_VERBOSE
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   elif defined __BUILTIN_VA_ARG_INCR
-#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
-#   elif defined _AIX
-#    define YYSTACK_ALLOC __alloca
-#   elif defined _MSC_VER
-#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
-#    define alloca _alloca
-#   else
-#    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
-#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
-#     ifndef EXIT_SUCCESS
-#      define EXIT_SUCCESS 0
-#     endif
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's 'empty if-body' warning.  */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-    /* The OS might guarantee only one guard page at the bottom of the stack,
-       and a page size can be as small as 4096 bytes.  So we cannot safely
-       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
-       to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
-#  endif
-# else
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
-#  endif
-#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
-       && ! ((defined YYMALLOC || defined malloc) \
-             && (defined YYFREE || defined free)))
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef EXIT_SUCCESS
-#    define EXIT_SUCCESS 0
-#   endif
-#  endif
-#  ifndef YYMALLOC
-#   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS
-void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifndef YYFREE
-#   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS
-void free (void *); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-# endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
-
-#if (! defined yyoverflow \
-     && (! defined __cplusplus \
-         || (defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL \
-             && defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  yytype_int16 yyss_alloc;
-  YYSTYPE yyvs_alloc;
-  YYLTYPE yyls_alloc;
-};
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \
-      + 2 * YYSTACK_GAP_MAXIMUM)
-
-# define YYCOPY_NEEDED 1
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
-    do                                                                  \
-      {                                                                 \
-        YYSIZE_T yynewbytes;                                            \
-        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
-        Stack = &yyptr->Stack_alloc;                                    \
-        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-        yyptr += yynewbytes / sizeof (*yyptr);                          \
-      }                                                                 \
-    while (0)
-
-#endif
-
-#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
-/* Copy COUNT objects from SRC to DST.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
-#   define YYCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
-#  else
-#   define YYCOPY(Dst, Src, Count)              \
-      do                                        \
-        {                                       \
-          YYSIZE_T yyi;                         \
-          for (yyi = 0; yyi < (Count); yyi++)   \
-            (Dst)[yyi] = (Src)[yyi];            \
-        }                                       \
-      while (0)
-#  endif
-# endif
-#endif /* !YYCOPY_NEEDED */
-
-/* YYFINAL -- State number of the termination state.  */
-#define YYFINAL  3
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   27
-
-/* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  13
-/* YYNNTS -- Number of nonterminals.  */
-#define YYNNTS  11
-/* YYNRULES -- Number of rules.  */
-#define YYNRULES  23
-/* YYNSTATES -- Number of states.  */
-#define YYNSTATES  32
-
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   262
-
-/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex, with out-of-bounds checking.  */
-#define YYTRANSLATE(YYX)                                                \
-  ((unsigned) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex.  */
-static const yytype_uint8 yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    12,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     9,
-       2,     8,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,    10,     2,    11,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7
-};
-
-#if YYDEBUG
-  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
-static const yytype_uint8 yyrline[] =
-{
-       0,    48,    48,    49,    51,    52,    54,    55,    56,    58,
-      59,    61,    62,    64,    65,    67,    68,    70,    71,    72,
-      74,    75,    77,    79
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE || 1
-/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "IDENT", "STRING", "NUMBER", "NEWLINE",
-  "\"+=\"", "'='", "';'", "'['", "']'", "','", "$accept", "file", "stmts",
-  "stmt", "assignment", "endstmt", "value", "atom", "valuelist", "values",
-  "nlok", YY_NULLPTR
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[NUM] -- (External) token number corresponding to the
-   (internal) symbol number NUM (which must be that of a token).  */
-static const yytype_uint16 yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,    61,    59,
-      91,    93,    44
-};
-# endif
-
-#define YYPACT_NINF -18
-
-#define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-18)))
-
-#define YYTABLE_NINF -3
-
-#define yytable_value_is_error(Yytable_value) \
-  0
-
-  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-     STATE-NUM.  */
-static const yytype_int8 yypact[] =
-{
-     -18,     5,     1,   -18,    -3,    14,   -18,   -18,   -18,     3,
-     -18,   -18,    10,    10,   -18,   -18,   -18,   -18,   -18,   -18,
-     -18,    13,   -18,   -18,    15,    12,    19,   -18,   -18,    13,
-     -18,    19
-};
-
-  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
-     Performed when YYTABLE does not specify something else to do.  Zero
-     means the default is an error.  */
-static const yytype_uint8 yydefact[] =
-{
-       4,     0,     0,     1,     0,     0,    11,    12,     5,     3,
-       7,     8,     0,     0,     6,    15,    16,    22,    10,    13,
-       9,    17,    23,    22,     0,    18,    20,    14,    22,    19,
-      22,    21
-};
-
-  /* YYPGOTO[NTERM-NUM].  */
-static const yytype_int8 yypgoto[] =
-{
-     -18,   -18,   -18,   -18,   -18,    18,   -13,   -18,   -18,   -18,
-     -17
-};
-
-  /* YYDEFGOTO[NTERM-NUM].  */
-static const yytype_int8 yydefgoto[] =
-{
-      -1,     1,     2,     8,     9,    10,    18,    19,    24,    25,
-      21
-};
-
-  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
-     positive, shift that token.  If negative, reduce the rule whose
-     number is the opposite.  If YYTABLE_NINF, syntax error.  */
-static const yytype_int8 yytable[] =
-{
-      20,    -2,     4,    11,     5,     3,    26,     6,    23,     6,
-       7,    29,     7,    31,    15,    16,    30,    15,    16,    22,
-      17,    12,    13,    17,    28,    22,    27,    14
-};
-
-static const yytype_uint8 yycheck[] =
-{
-      13,     0,     1,     6,     3,     0,    23,     6,    21,     6,
-       9,    28,     9,    30,     4,     5,    29,     4,     5,     6,
-      10,     7,     8,    10,    12,     6,    11,     9
-};
-
-  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-     symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
-{
-       0,    14,    15,     0,     1,     3,     6,     9,    16,    17,
-      18,     6,     7,     8,    18,     4,     5,    10,    19,    20,
-      19,    23,     6,    19,    21,    22,    23,    11,    12,    23,
-      19,    23
-};
-
-  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
-{
-       0,    13,    14,    14,    15,    15,    16,    16,    16,    17,
-      17,    18,    18,    19,    19,    20,    20,    21,    21,    21,
-      22,    22,    23,    23
-};
-
-  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
-{
-       0,     2,     1,     2,     0,     2,     2,     1,     2,     3,
-       3,     1,     1,     1,     4,     1,     1,     0,     1,     3,
-       2,     5,     0,     2
-};
-
-
-#define yyerrok         (yyerrstatus = 0)
-#define yyclearin       (yychar = YYEMPTY)
-#define YYEMPTY         (-2)
-#define YYEOF           0
-
-#define YYACCEPT        goto yyacceptlab
-#define YYABORT         goto yyabortlab
-#define YYERROR         goto yyerrorlab
-
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)                                    \
-  do                                                              \
-    if (yychar == YYEMPTY)                                        \
-      {                                                           \
-        yychar = (Token);                                         \
-        yylval = (Value);                                         \
-        YYPOPSTACK (yylen);                                       \
-        yystate = *yyssp;                                         \
-        goto yybackup;                                            \
-      }                                                           \
-    else                                                          \
-      {                                                           \
-        yyerror (&yylloc, ctx, YY_("syntax error: cannot back up")); \
-        YYERROR;                                                  \
-      }                                                           \
-  while (0)
-
-/* Error token number */
-#define YYTERROR        1
-#define YYERRCODE       256
-
-
-/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
-   If N is 0, then set CURRENT to the empty location which ends
-   the previous symbol: RHS[0] (always defined).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
-    do                                                                  \
-      if (N)                                                            \
-        {                                                               \
-          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \
-          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \
-          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \
-          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \
-        }                                                               \
-      else                                                              \
-        {                                                               \
-          (Current).first_line   = (Current).last_line   =              \
-            YYRHSLOC (Rhs, 0).last_line;                                \
-          (Current).first_column = (Current).last_column =              \
-            YYRHSLOC (Rhs, 0).last_column;                              \
-        }                                                               \
-    while (0)
-#endif
-
-#define YYRHSLOC(Rhs, K) ((Rhs)[K])
-
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)                        \
-do {                                            \
-  if (yydebug)                                  \
-    YYFPRINTF Args;                             \
-} while (0)
-
-
-/* YY_LOCATION_PRINT -- Print the location on the stream.
-   This macro was not mandated originally: define only if we know
-   we won't break user code: when these are the locations we know.  */
-
-#ifndef YY_LOCATION_PRINT
-# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
-
-/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */
-
-YY_ATTRIBUTE_UNUSED
-static int
-yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)
-{
-  int res = 0;
-  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;
-  if (0 <= yylocp->first_line)
-    {
-      res += YYFPRINTF (yyo, "%d", yylocp->first_line);
-      if (0 <= yylocp->first_column)
-        res += YYFPRINTF (yyo, ".%d", yylocp->first_column);
-    }
-  if (0 <= yylocp->last_line)
-    {
-      if (yylocp->first_line < yylocp->last_line)
-        {
-          res += YYFPRINTF (yyo, "-%d", yylocp->last_line);
-          if (0 <= end_col)
-            res += YYFPRINTF (yyo, ".%d", end_col);
-        }
-      else if (0 <= end_col && yylocp->first_column < end_col)
-        res += YYFPRINTF (yyo, "-%d", end_col);
-    }
-  return res;
- }
-
-#  define YY_LOCATION_PRINT(File, Loc)          \
-  yy_location_print_ (File, &(Loc))
-
-# else
-#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-# endif
-#endif
-
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
-do {                                                                      \
-  if (yydebug)                                                            \
-    {                                                                     \
-      YYFPRINTF (stderr, "%s ", Title);                                   \
-      yy_symbol_print (stderr,                                            \
-                  Type, Value, Location, ctx); \
-      YYFPRINTF (stderr, "\n");                                           \
-    }                                                                     \
-} while (0)
-
-
-/*-----------------------------------.
-| Print this symbol's value on YYO.  |
-`-----------------------------------*/
-
-static void
-yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, CfgParseContext *ctx)
-{
-  FILE *yyoutput = yyo;
-  YYUSE (yyoutput);
-  YYUSE (yylocationp);
-  YYUSE (ctx);
-  if (!yyvaluep)
-    return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
-# endif
-  YYUSE (yytype);
-}
-
-
-/*---------------------------.
-| Print this symbol on YYO.  |
-`---------------------------*/
-
-static void
-yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, CfgParseContext *ctx)
-{
-  YYFPRINTF (yyo, "%s %s (",
-             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
-
-  YY_LOCATION_PRINT (yyo, *yylocationp);
-  YYFPRINTF (yyo, ": ");
-  yy_symbol_value_print (yyo, yytype, yyvaluep, yylocationp, ctx);
-  YYFPRINTF (yyo, ")");
-}
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (; yybottom <= yytop; yybottom++)
-    {
-      int yybot = *yybottom;
-      YYFPRINTF (stderr, " %d", yybot);
-    }
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)                            \
-do {                                                            \
-  if (yydebug)                                                  \
-    yy_stack_print ((Bottom), (Top));                           \
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-static void
-yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule, CfgParseContext *ctx)
-{
-  unsigned long yylno = yyrline[yyrule];
-  int yynrhs = yyr2[yyrule];
-  int yyi;
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-             yyrule - 1, yylno);
-  /* The symbols being reduced.  */
-  for (yyi = 0; yyi < yynrhs; yyi++)
-    {
-      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
-      yy_symbol_print (stderr,
-                       yystos[yyssp[yyi + 1 - yynrhs]],
-                       &yyvsp[(yyi + 1) - (yynrhs)]
-                       , &(yylsp[(yyi + 1) - (yynrhs)])                       , ctx);
-      YYFPRINTF (stderr, "\n");
-    }
-}
-
-# define YY_REDUCE_PRINT(Rule)          \
-do {                                    \
-  if (yydebug)                          \
-    yy_reduce_print (yyssp, yyvsp, yylsp, Rule, ctx); \
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-yystrlen (const char *yystr)
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-        switch (*++yyp)
-          {
-          case '\'':
-          case ',':
-            goto do_not_strip_quotes;
-
-          case '\\':
-            if (*++yyp != '\\')
-              goto do_not_strip_quotes;
-            else
-              goto append;
-
-          append:
-          default:
-            if (yyres)
-              yyres[yyn] = *yyp;
-            yyn++;
-            break;
-
-          case '"':
-            if (yyres)
-              yyres[yyn] = '\0';
-            return yyn;
-          }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return (YYSIZE_T) (yystpcpy (yyres, yystr) - yyres);
-}
-# endif
-
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
-{
-  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = YY_NULLPTR;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
-                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
-                    yysize = yysize1;
-                  else
-                    return 2;
-                }
-              }
-        }
-    }
-
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-    default: /* Avoid compiler warnings. */
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
-
-  {
-    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
-    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
-      yysize = yysize1;
-    else
-      return 2;
-  }
-
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
-
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, CfgParseContext *ctx)
-{
-  YYUSE (yyvaluep);
-  YYUSE (yylocationp);
-  YYUSE (ctx);
-  if (!yymsg)
-    yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
-
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  switch (yytype)
-    {
-    case 3: /* IDENT  */
-#line 40 "libxlu_cfg_y.y" /* yacc.c:1257  */
-      { free(((*yyvaluep).string)); }
-#line 1072 "libxlu_cfg_y.c" /* yacc.c:1257  */
-        break;
-
-    case 4: /* STRING  */
-#line 40 "libxlu_cfg_y.y" /* yacc.c:1257  */
-      { free(((*yyvaluep).string)); }
-#line 1078 "libxlu_cfg_y.c" /* yacc.c:1257  */
-        break;
-
-    case 5: /* NUMBER  */
-#line 40 "libxlu_cfg_y.y" /* yacc.c:1257  */
-      { free(((*yyvaluep).string)); }
-#line 1084 "libxlu_cfg_y.c" /* yacc.c:1257  */
-        break;
-
-    case 19: /* value  */
-#line 44 "libxlu_cfg_y.y" /* yacc.c:1257  */
-      { xlu__cfg_value_free(((*yyvaluep).value)); }
-#line 1090 "libxlu_cfg_y.c" /* yacc.c:1257  */
-        break;
-
-    case 20: /* atom  */
-#line 40 "libxlu_cfg_y.y" /* yacc.c:1257  */
-      { free(((*yyvaluep).string)); }
-#line 1096 "libxlu_cfg_y.c" /* yacc.c:1257  */
-        break;
-
-    case 21: /* valuelist  */
-#line 44 "libxlu_cfg_y.y" /* yacc.c:1257  */
-      { xlu__cfg_value_free(((*yyvaluep).value)); }
-#line 1102 "libxlu_cfg_y.c" /* yacc.c:1257  */
-        break;
-
-    case 22: /* values  */
-#line 44 "libxlu_cfg_y.y" /* yacc.c:1257  */
-      { xlu__cfg_value_free(((*yyvaluep).value)); }
-#line 1108 "libxlu_cfg_y.c" /* yacc.c:1257  */
-        break;
-
-      default:
-        break;
-    }
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
-}
-
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-int
-yyparse (CfgParseContext *ctx)
-{
-/* The lookahead symbol.  */
-int yychar;
-
-
-/* The semantic value of the lookahead symbol.  */
-/* Default value used for initialization, for pacifying older GCCs
-   or non-GCC compilers.  */
-YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
-YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
-
-/* Location data for the lookahead symbol.  */
-static YYLTYPE yyloc_default
-# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
-  = { 1, 1, 1, 1 }
-# endif
-;
-YYLTYPE yylloc = yyloc_default;
-
-    /* Number of syntax errors so far.  */
-    int yynerrs;
-
-    int yystate;
-    /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       'yyss': related to states.
-       'yyvs': related to semantic values.
-       'yyls': related to locations.
-
-       Refer to the stacks through separate pointers, to allow yyoverflow
-       to reallocate them elsewhere.  */
-
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
-
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
-
-    /* The location stack.  */
-    YYLTYPE yylsa[YYINITDEPTH];
-    YYLTYPE *yyls;
-    YYLTYPE *yylsp;
-
-    /* The locations where the error started and ended.  */
-    YYLTYPE yyerror_range[3];
-
-    YYSIZE_T yystacksize;
-
-  int yyn;
-  int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-  YYLTYPE yyloc;
-
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
-
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))
-
-  /* The number of symbols on the RHS of the reduced rule.
-     Keep to zero when no symbol should be popped.  */
-  int yylen = 0;
-
-  yyssp = yyss = yyssa;
-  yyvsp = yyvs = yyvsa;
-  yylsp = yyls = yylsa;
-  yystacksize = YYINITDEPTH;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY; /* Cause a token to be read.  */
-  yylsp[0] = yylloc;
-  goto yysetstate;
-
-
-/*------------------------------------------------------------.
-| yynewstate -- push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
-yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed.  So pushing a state here evens the stacks.  */
-  yyssp++;
-
-
-/*--------------------------------------------------------------------.
-| yynewstate -- set current state (the top of the stack) to yystate.  |
-`--------------------------------------------------------------------*/
-yysetstate:
-  *yyssp = (yytype_int16) yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-#if !defined yyoverflow && !defined YYSTACK_RELOCATE
-    goto yyexhaustedlab;
-#else
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = (YYSIZE_T) (yyssp - yyss + 1);
-
-# if defined yyoverflow
-      {
-        /* Give user a chance to reallocate the stack.  Use copies of
-           these so that the &'s don't force the real ones into
-           memory.  */
-        YYSTYPE *yyvs1 = yyvs;
-        yytype_int16 *yyss1 = yyss;
-        YYLTYPE *yyls1 = yyls;
-
-        /* Each stack pointer address is followed by the size of the
-           data in use in that stack, in bytes.  This used to be a
-           conditional around just the two extra args, but that might
-           be undefined if yyoverflow is a macro.  */
-        yyoverflow (YY_("memory exhausted"),
-                    &yyss1, yysize * sizeof (*yyssp),
-                    &yyvs1, yysize * sizeof (*yyvsp),
-                    &yyls1, yysize * sizeof (*yylsp),
-                    &yystacksize);
-        yyss = yyss1;
-        yyvs = yyvs1;
-        yyls = yyls1;
-      }
-# else /* defined YYSTACK_RELOCATE */
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-        goto yyexhaustedlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-        yystacksize = YYMAXDEPTH;
-
-      {
-        yytype_int16 *yyss1 = yyss;
-        union yyalloc *yyptr =
-          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-        if (! yyptr)
-          goto yyexhaustedlab;
-        YYSTACK_RELOCATE (yyss_alloc, yyss);
-        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
-        YYSTACK_RELOCATE (yyls_alloc, yyls);
-# undef YYSTACK_RELOCATE
-        if (yyss1 != yyssa)
-          YYSTACK_FREE (yyss1);
-      }
-# endif
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-      yylsp = yyls + yysize - 1;
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-                  (unsigned long) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-        YYABORT;
-    }
-#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  if (yystate == YYFINAL)
-    YYACCEPT;
-
-  goto yybackup;
-
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-  /* Do appropriate processing given the current state.  Read a
-     lookahead token if we need one and don't already have one.  */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-  yyn = yypact[yystate];
-  if (yypact_value_is_default (yyn))
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = yylex (&yylval, &yylloc, ctx_scanner);
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yytable_value_is_error (yyn))
-        goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  /* Shift the lookahead token.  */
-  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
-
-  yystate = yyn;
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  *++yyvsp = yylval;
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
-  *++yylsp = yylloc;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     '$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-  /* Default location. */
-  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
-  yyerror_range[1] = yyloc;
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 9:
-#line 58 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { xlu__cfg_set_store(ctx,(yyvsp[-2].string),XLU_OP_ASSIGNMENT,(yyvsp[0].value),(yylsp[0]).first_line); }
-#line 1406 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 10:
-#line 59 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { xlu__cfg_set_store(ctx,(yyvsp[-2].string),XLU_OP_ADDITION,(yyvsp[0].value),(yylsp[0]).first_line); }
-#line 1412 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 13:
-#line 64 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { (yyval.value)= xlu__cfg_string_mk(ctx,(yyvsp[0].string),&(yylsp[0])); }
-#line 1418 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 14:
-#line 65 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { (yyval.value)= (yyvsp[-1].value); }
-#line 1424 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 15:
-#line 67 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { (yyval.string)= (yyvsp[0].string); }
-#line 1430 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 16:
-#line 68 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { (yyval.string)= (yyvsp[0].string); }
-#line 1436 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 17:
-#line 70 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { (yyval.value)= xlu__cfg_list_mk(ctx,NULL,&yylloc); }
-#line 1442 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 18:
-#line 71 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { (yyval.value)= (yyvsp[0].value); }
-#line 1448 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 19:
-#line 72 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { (yyval.value)= (yyvsp[-2].value); }
-#line 1454 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 20:
-#line 74 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { (yyval.value)= xlu__cfg_list_mk(ctx,(yyvsp[-1].value),&(yylsp[-1])); }
-#line 1460 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-  case 21:
-#line 75 "libxlu_cfg_y.y" /* yacc.c:1652  */
-    { xlu__cfg_list_append(ctx,(yyvsp[-4].value),(yyvsp[-1].value)); (yyval.value)= (yyvsp[-4].value); }
-#line 1466 "libxlu_cfg_y.c" /* yacc.c:1652  */
-    break;
-
-
-#line 1470 "libxlu_cfg_y.c" /* yacc.c:1652  */
-      default: break;
-    }
-  /* User semantic actions sometimes alter yychar, and that requires
-     that yytoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of yytoken.
-     One alternative is translating here after every semantic action,
-     but that translation would be missed if the semantic action invokes
-     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
-     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
-     incorrect destructor might then be invoked immediately.  In the
-     case of YYERROR or YYBACKUP, subsequent parser actions might lead
-     to an incorrect destructor call or verbose syntax error message
-     before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
-
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-  *++yylsp = yyloc;
-
-  /* Now 'shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-  {
-    const int yylhs = yyr1[yyn] - YYNTOKENS;
-    const int yyi = yypgoto[yylhs] + *yyssp;
-    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
-               ? yytable[yyi]
-               : yydefgoto[yylhs]);
-  }
-
-  goto yynewstate;
-
-
-/*--------------------------------------.
-| yyerrlab -- here on detecting error.  |
-`--------------------------------------*/
-yyerrlab:
-  /* Make sure we have latest lookahead translation.  See comments at
-     user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if ! YYERROR_VERBOSE
-      yyerror (&yylloc, ctx, YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (&yylloc, ctx, yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
-    }
-
-  yyerror_range[1] = yylloc;
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-         error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* Return failure if at end of input.  */
-          if (yychar == YYEOF)
-            YYABORT;
-        }
-      else
-        {
-          yydestruct ("Error: discarding",
-                      yytoken, &yylval, &yylloc, ctx);
-          yychar = YYEMPTY;
-        }
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-  /* Pacify compilers when the user code never invokes YYERROR and the
-     label yyerrorlab therefore never appears in user code.  */
-  if (0)
-    YYERROR;
-
-  /* Do not reclaim the symbols of the rule whose action triggered
-     this YYERROR.  */
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (!yypact_value_is_default (yyn))
-        {
-          yyn += YYTERROR;
-          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-            {
-              yyn = yytable[yyn];
-              if (0 < yyn)
-                break;
-            }
-        }
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-        YYABORT;
-
-      yyerror_range[1] = *yylsp;
-      yydestruct ("Error: popping",
-                  yystos[yystate], yyvsp, yylsp, ctx);
-      YYPOPSTACK (1);
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  *++yyvsp = yylval;
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
-
-  yyerror_range[2] = yylloc;
-  /* Using YYLLOC is tempting, but would change the location of
-     the lookahead.  YYLOC is available though.  */
-  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
-  *++yylsp = yyloc;
-
-  /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-
-#if !defined yyoverflow || YYERROR_VERBOSE
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-yyexhaustedlab:
-  yyerror (&yylloc, ctx, YY_("memory exhausted"));
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-
-/*-----------------------------------------------------.
-| yyreturn -- parsing is finished, return the result.  |
-`-----------------------------------------------------*/
-yyreturn:
-  if (yychar != YYEMPTY)
-    {
-      /* Make sure we have latest lookahead translation.  See comments at
-         user semantic actions for why this is necessary.  */
-      yytoken = YYTRANSLATE (yychar);
-      yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval, &yylloc, ctx);
-    }
-  /* Do not reclaim the symbols of the rule whose action triggered
-     this YYABORT or YYACCEPT.  */
-  YYPOPSTACK (yylen);
-  YY_STACK_PRINT (yyss, yyssp);
-  while (yyssp != yyss)
-    {
-      yydestruct ("Cleanup: popping",
-                  yystos[*yyssp], yyvsp, yylsp, ctx);
-      YYPOPSTACK (1);
-    }
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
-  return yyresult;
-}
diff --git a/tools/libs/util/libxlu_cfg_y.h b/tools/libs/util/libxlu_cfg_y.h
deleted file mode 100644
index 1233cb94fc..0000000000
--- a/tools/libs/util/libxlu_cfg_y.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/* A Bison parser, made by GNU Bison 3.3.2.  */
-
-/* Bison interface for Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
-   Inc.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
-
-/* Undocumented macros, especially those whose name start with YY_,
-   are private implementation details.  Do not rely on them.  */
-
-#ifndef YY_XLU_CFG_YY_LIBXLU_CFG_Y_H_INCLUDED
-# define YY_XLU_CFG_YY_LIBXLU_CFG_Y_H_INCLUDED
-/* Debug traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-#if YYDEBUG
-extern int xlu__cfg_yydebug;
-#endif
-
-/* Token type.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-  enum yytokentype
-  {
-    IDENT = 258,
-    STRING = 259,
-    NUMBER = 260,
-    NEWLINE = 261,
-    OP_ADD = 262
-  };
-#endif
-
-/* Value type.  */
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-
-union YYSTYPE
-{
-#line 25 "libxlu_cfg_y.y" /* yacc.c:1921  */
-
-  char *string;
-  XLU_ConfigValue *value;
-
-#line 71 "libxlu_cfg_y.h" /* yacc.c:1921  */
-};
-
-typedef union YYSTYPE YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-/* Location type.  */
-#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
-typedef struct YYLTYPE YYLTYPE;
-struct YYLTYPE
-{
-  int first_line;
-  int first_column;
-  int last_line;
-  int last_column;
-};
-# define YYLTYPE_IS_DECLARED 1
-# define YYLTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-int xlu__cfg_yyparse (CfgParseContext *ctx);
-
-#endif /* !YY_XLU_CFG_YY_LIBXLU_CFG_Y_H_INCLUDED  */
diff --git a/tools/libs/util/libxlu_disk_l.c b/tools/libs/util/libxlu_disk_l.c
deleted file mode 100644
index 0b59723b71..0000000000
--- a/tools/libs/util/libxlu_disk_l.c
+++ /dev/null
@@ -1,2975 +0,0 @@
-#line 1 "libxlu_disk_l.c"
-#define _GNU_SOURCE
-
-#line 4 "libxlu_disk_l.c"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 4
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-#ifdef yy_create_buffer
-#define xlu__disk_yy_create_buffer_ALREADY_DEFINED
-#else
-#define yy_create_buffer xlu__disk_yy_create_buffer
-#endif
-
-#ifdef yy_delete_buffer
-#define xlu__disk_yy_delete_buffer_ALREADY_DEFINED
-#else
-#define yy_delete_buffer xlu__disk_yy_delete_buffer
-#endif
-
-#ifdef yy_scan_buffer
-#define xlu__disk_yy_scan_buffer_ALREADY_DEFINED
-#else
-#define yy_scan_buffer xlu__disk_yy_scan_buffer
-#endif
-
-#ifdef yy_scan_string
-#define xlu__disk_yy_scan_string_ALREADY_DEFINED
-#else
-#define yy_scan_string xlu__disk_yy_scan_string
-#endif
-
-#ifdef yy_scan_bytes
-#define xlu__disk_yy_scan_bytes_ALREADY_DEFINED
-#else
-#define yy_scan_bytes xlu__disk_yy_scan_bytes
-#endif
-
-#ifdef yy_init_buffer
-#define xlu__disk_yy_init_buffer_ALREADY_DEFINED
-#else
-#define yy_init_buffer xlu__disk_yy_init_buffer
-#endif
-
-#ifdef yy_flush_buffer
-#define xlu__disk_yy_flush_buffer_ALREADY_DEFINED
-#else
-#define yy_flush_buffer xlu__disk_yy_flush_buffer
-#endif
-
-#ifdef yy_load_buffer_state
-#define xlu__disk_yy_load_buffer_state_ALREADY_DEFINED
-#else
-#define yy_load_buffer_state xlu__disk_yy_load_buffer_state
-#endif
-
-#ifdef yy_switch_to_buffer
-#define xlu__disk_yy_switch_to_buffer_ALREADY_DEFINED
-#else
-#define yy_switch_to_buffer xlu__disk_yy_switch_to_buffer
-#endif
-
-#ifdef yypush_buffer_state
-#define xlu__disk_yypush_buffer_state_ALREADY_DEFINED
-#else
-#define yypush_buffer_state xlu__disk_yypush_buffer_state
-#endif
-
-#ifdef yypop_buffer_state
-#define xlu__disk_yypop_buffer_state_ALREADY_DEFINED
-#else
-#define yypop_buffer_state xlu__disk_yypop_buffer_state
-#endif
-
-#ifdef yyensure_buffer_stack
-#define xlu__disk_yyensure_buffer_stack_ALREADY_DEFINED
-#else
-#define yyensure_buffer_stack xlu__disk_yyensure_buffer_stack
-#endif
-
-#ifdef yylex
-#define xlu__disk_yylex_ALREADY_DEFINED
-#else
-#define yylex xlu__disk_yylex
-#endif
-
-#ifdef yyrestart
-#define xlu__disk_yyrestart_ALREADY_DEFINED
-#else
-#define yyrestart xlu__disk_yyrestart
-#endif
-
-#ifdef yylex_init
-#define xlu__disk_yylex_init_ALREADY_DEFINED
-#else
-#define yylex_init xlu__disk_yylex_init
-#endif
-
-#ifdef yylex_init_extra
-#define xlu__disk_yylex_init_extra_ALREADY_DEFINED
-#else
-#define yylex_init_extra xlu__disk_yylex_init_extra
-#endif
-
-#ifdef yylex_destroy
-#define xlu__disk_yylex_destroy_ALREADY_DEFINED
-#else
-#define yylex_destroy xlu__disk_yylex_destroy
-#endif
-
-#ifdef yyget_debug
-#define xlu__disk_yyget_debug_ALREADY_DEFINED
-#else
-#define yyget_debug xlu__disk_yyget_debug
-#endif
-
-#ifdef yyset_debug
-#define xlu__disk_yyset_debug_ALREADY_DEFINED
-#else
-#define yyset_debug xlu__disk_yyset_debug
-#endif
-
-#ifdef yyget_extra
-#define xlu__disk_yyget_extra_ALREADY_DEFINED
-#else
-#define yyget_extra xlu__disk_yyget_extra
-#endif
-
-#ifdef yyset_extra
-#define xlu__disk_yyset_extra_ALREADY_DEFINED
-#else
-#define yyset_extra xlu__disk_yyset_extra
-#endif
-
-#ifdef yyget_in
-#define xlu__disk_yyget_in_ALREADY_DEFINED
-#else
-#define yyget_in xlu__disk_yyget_in
-#endif
-
-#ifdef yyset_in
-#define xlu__disk_yyset_in_ALREADY_DEFINED
-#else
-#define yyset_in xlu__disk_yyset_in
-#endif
-
-#ifdef yyget_out
-#define xlu__disk_yyget_out_ALREADY_DEFINED
-#else
-#define yyget_out xlu__disk_yyget_out
-#endif
-
-#ifdef yyset_out
-#define xlu__disk_yyset_out_ALREADY_DEFINED
-#else
-#define yyset_out xlu__disk_yyset_out
-#endif
-
-#ifdef yyget_leng
-#define xlu__disk_yyget_leng_ALREADY_DEFINED
-#else
-#define yyget_leng xlu__disk_yyget_leng
-#endif
-
-#ifdef yyget_text
-#define xlu__disk_yyget_text_ALREADY_DEFINED
-#else
-#define yyget_text xlu__disk_yyget_text
-#endif
-
-#ifdef yyget_lineno
-#define xlu__disk_yyget_lineno_ALREADY_DEFINED
-#else
-#define yyget_lineno xlu__disk_yyget_lineno
-#endif
-
-#ifdef yyset_lineno
-#define xlu__disk_yyset_lineno_ALREADY_DEFINED
-#else
-#define yyset_lineno xlu__disk_yyset_lineno
-#endif
-
-#ifdef yyget_column
-#define xlu__disk_yyget_column_ALREADY_DEFINED
-#else
-#define yyget_column xlu__disk_yyget_column
-#endif
-
-#ifdef yyset_column
-#define xlu__disk_yyset_column_ALREADY_DEFINED
-#else
-#define yyset_column xlu__disk_yyset_column
-#endif
-
-#ifdef yywrap
-#define xlu__disk_yywrap_ALREADY_DEFINED
-#else
-#define yywrap xlu__disk_yywrap
-#endif
-
-#ifdef yyalloc
-#define xlu__disk_yyalloc_ALREADY_DEFINED
-#else
-#define yyalloc xlu__disk_yyalloc
-#endif
-
-#ifdef yyrealloc
-#define xlu__disk_yyrealloc_ALREADY_DEFINED
-#else
-#define yyrealloc xlu__disk_yyrealloc
-#endif
-
-#ifdef yyfree
-#define xlu__disk_yyfree_ALREADY_DEFINED
-#else
-#define yyfree xlu__disk_yyfree
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#ifndef SIZE_MAX
-#define SIZE_MAX               (~(size_t)0)
-#endif
-
-#endif /* ! C99 */
-
-#endif /* ! FLEXINT_H */
-
-/* begin standard C++ headers. */
-
-/* TODO: this is always defined, so inline it */
-#define yyconst const
-
-#if defined(__GNUC__) && __GNUC__ >= 3
-#define yynoreturn __attribute__((__noreturn__))
-#else
-#define yynoreturn
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an
- *   integer in range [0..255] for use as an array index.
- */
-#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
-
-/* An opaque pointer. */
-#ifndef YY_TYPEDEF_YY_SCANNER_T
-#define YY_TYPEDEF_YY_SCANNER_T
-typedef void* yyscan_t;
-#endif
-
-/* For convenience, these vars (plus the bison vars far below)
-   are macros in the reentrant scanner. */
-#define yyin yyg->yyin_r
-#define yyout yyg->yyout_r
-#define yyextra yyg->yyextra_r
-#define yyleng yyg->yyleng_r
-#define yytext yyg->yytext_r
-#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
-#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
-#define yy_flex_debug yyg->yy_flex_debug_r
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yyg->yy_start = 1 + 2 *
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yyg->yy_start - 1) / 2)
-#define YYSTATE YY_START
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin , yyscanner )
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k.
- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
- * Ditto for the __ia64__ case accordingly.
- */
-#define YY_BUF_SIZE 32768
-#else
-#define YY_BUF_SIZE 16384
-#endif /* __ia64__ */
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-    
-    #define YY_LESS_LINENO(n)
-    #define YY_LINENO_REWIND_TO(ptr)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = yyg->yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	int yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
-                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
-                          : NULL)
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]
-
-void yyrestart ( FILE *input_file , yyscan_t yyscanner );
-void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
-void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-void yypop_buffer_state ( yyscan_t yyscanner );
-
-static void yyensure_buffer_stack ( yyscan_t yyscanner );
-static void yy_load_buffer_state ( yyscan_t yyscanner );
-static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file , yyscan_t yyscanner );
-#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER , yyscanner)
-
-YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );
-
-void *yyalloc ( yy_size_t , yyscan_t yyscanner );
-void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
-void yyfree ( void * , yyscan_t yyscanner );
-
-#define yy_new_buffer yy_create_buffer
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (yyscanner); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (yyscanner); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-#define xlu__disk_yywrap(yyscanner) (/*CONSTCOND*/1)
-#define YY_SKIP_YYWRAP
-typedef flex_uint8_t YY_CHAR;
-
-typedef int yy_state_type;
-
-#define yytext_ptr yytext_r
-
-static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
-static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  , yyscan_t yyscanner);
-static int yy_get_next_buffer ( yyscan_t yyscanner );
-static void yynoreturn yy_fatal_error ( const char* msg , yyscan_t yyscanner );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yyg->yytext_ptr = yy_bp; \
-	yyg->yytext_ptr -= yyg->yy_more_len; \
-	yyleng = (int) (yy_cp - yyg->yytext_ptr); \
-	yyg->yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yyg->yy_c_buf_p = yy_cp;
-#define YY_NUM_RULES 37
-#define YY_END_OF_BUFFER 38
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static const flex_int16_t yy_acclist[594] =
-    {   0,
-       36,   36,   38,   34,   35,   37, 8193,   34,   35,   37,
-    16385, 8193,   34,   37,16385,   34,   35,   37,   35,   37,
-       34,   35,   37,   34,   35,   37,   34,   35,   37,   34,
-       35,   37,   34,   35,   37,   34,   35,   37,   34,   35,
-       37,   34,   35,   37,   34,   35,   37,   34,   35,   37,
-       34,   35,   37,   34,   35,   37,   34,   35,   37,   34,
-       35,   37,   34,   35,   37,   34,   35,   37,   36,   37,
-       37,   34,   34, 8193,   34, 8193,   34,16385, 8193,   34,
-     8193,   34,   34, 8225,   34,16417,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       36, 8193,   34, 8193,   34, 8193, 8225,   34, 8225,   34,
-     8225,   24,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34, 8225,   34, 8225,
-       34, 8225,   24,   34,   34,   29, 8225,   34,16417,   34,
-       34,   16,   34,   34,   34,   34,   34,   34,   34,   34,
-       34, 8218, 8225,   34,16410,16417,   34,   34,   32, 8225,
-       34,16417,   34, 8217, 8225,   34,16409,16417,   34,   34,
-       34, 8220, 8225,   34,16412,16417,   34,   34,   34,   34,
-
-       34,   29, 8225,   34,   29, 8225,   34,   29,   34,   29,
-     8225,   34,    3,   34,   16,   34,   34,   34,   34,   34,
-       31, 8225,   34,16417,   34,   34,   34, 8218, 8225,   34,
-     8218, 8225,   34, 8218,   34, 8218, 8225,   34,   34,   32,
-     8225,   34,   32, 8225,   34,   32,   34,   32, 8225, 8217,
-     8225,   34, 8217, 8225,   34, 8217,   34, 8217, 8225,   34,
-       34, 8220, 8225,   34, 8220, 8225,   34, 8220,   34, 8220,
-     8225,   34,   34,   11,   34,   34,   29, 8225,   34,   29,
-     8225,   34,   29, 8225,   29,   34,   29,   34,    3,   34,
-       34,   34,   34,   34,   34,   34,   31, 8225,   34,   31,
-
-     8225,   34,   31,   34,   31, 8225,   34,   34,   30, 8225,
-       34,16417, 8218, 8225,   34, 8218, 8225,   34, 8218, 8225,
-     8218,   34, 8218,   34,   34,   32, 8225,   34,   32, 8225,
-       34,   32, 8225,   32,   34,   32, 8217, 8225,   34, 8217,
-     8225,   34, 8217, 8225, 8217,   34, 8217,   34,   34, 8220,
-     8225,   34, 8220, 8225,   34, 8220, 8225, 8220,   34, 8220,
-       34,   34,   11,   24,   11,    7,   34,   34,   34,   34,
-       34,   34,   34,   14,   34,   31, 8225,   34,   31, 8225,
-       34,   31, 8225,   31,   34,   31,    2,   34,   30, 8225,
-       34,   30, 8225,   34,   30,   34,   30, 8225,   17,   34,
-
-       34,   12,   34,   34,   23,   11,   11,   24,    7,   24,
-        7,   34,    8,   34,   34,   34,   34,    6,   34,   14,
-       34,    2,   24,    2,   34,   30, 8225,   34,   30, 8225,
-       34,   30, 8225,   30,   34,   30,   17,   34,   34,   12,
-       24,   12,   34,   27, 8225,   34,16417,   23,   24,   23,
-        7,    7,   24,   34,    8,   24,    8,   34,   34,   34,
-       34,    6,   24,    6,    6,   24,    6,   24,   34,    2,
-        2,   24,   34,   34,   12,   12,   24,   34,   27, 8225,
-       34,   27, 8225,   34,   27,   34,   27, 8225,   23,   24,
-       34,    8,    8,   24,   34,   34,   18,   19,    6,    6,
-
-       24,    6,    6,   34,   34,   15,   34,   34,   27, 8225,
-       34,   27, 8225,   34,   27, 8225,   27,   34,   27,   34,
-       34,   34,   18,   24,   18,   19,   24,   19,    6,    6,
-       34,   34,   15,   34,   34,   21,    9,   20,   18,   18,
-       24,   19,   19,   24,    6,    5,    6,   34,   22,   34,
-       21,   24,   21,    9,   24,    9,   20,   24,   20,    4,
-        6,    5,    6,   34,   22,   24,   22,   34,   21,   21,
-       24,    9,    9,   24,   20,   20,   24,    4,    6,   13,
-       34,   22,   22,   24,   10,   13,   34,   10,   24,   10,
-       10,   10,   24
-
-    } ;
-
-static const flex_int16_t yy_accept[373] =
-    {   0,
-        1,    1,    1,    2,    3,    4,    7,   12,   16,   19,
-       21,   24,   27,   30,   33,   36,   39,   42,   45,   48,
-       51,   54,   57,   60,   63,   66,   69,   71,   72,   73,
-       74,   76,   79,   81,   82,   83,   84,   87,   87,   88,
-       89,   90,   91,   92,   93,   94,   95,   96,   97,   98,
-       99,  100,  101,  102,  103,  104,  105,  106,  107,  108,
-      109,  110,  111,  112,  114,  116,  117,  119,  121,  122,
-      123,  124,  125,  126,  127,  128,  129,  130,  131,  132,
-      133,  134,  135,  136,  137,  138,  139,  140,  141,  142,
-      143,  144,  145,  146,  147,  148,  150,  152,  153,  154,
-
-      155,  156,  160,  161,  162,  164,  165,  166,  167,  168,
-      169,  170,  171,  172,  177,  178,  179,  183,  184,  189,
-      190,  191,  192,  197,  198,  199,  200,  201,  202,  205,
-      208,  210,  212,  213,  215,  217,  218,  219,  220,  221,
-      225,  226,  227,  228,  231,  234,  236,  238,  239,  240,
-      243,  246,  248,  250,  253,  256,  258,  260,  261,  262,
-      265,  268,  270,  272,  273,  274,  275,  276,  277,  280,
-      283,  285,  287,  288,  289,  291,  292,  293,  294,  295,
-      296,  297,  300,  303,  305,  307,  308,  309,  313,  316,
-      319,  321,  323,  324,  325,  326,  329,  332,  334,  336,
-
-      337,  340,  343,  345,  347,  348,  349,  350,  353,  356,
-      358,  360,  361,  362,  363,  365,  366,  367,  368,  369,
-      370,  371,  372,  373,  374,  376,  379,  382,  384,  386,
-      387,  388,  389,  392,  395,  397,  399,  401,  402,  403,
-      404,  405,  406,  407,  409,  411,  412,  413,  414,  415,
-      416,  417,  418,  419,  420,  422,  424,  425,  426,  429,
-      432,  434,  436,  437,  439,  440,  442,  443,  444,  448,
-      450,  451,  452,  454,  455,  457,  458,  459,  460,  461,
-      462,  464,  465,  467,  469,  470,  471,  473,  474,  475,
-      476,  478,  479,  482,  485,  487,  489,  491,  492,  493,
-
-      495,  496,  497,  498,  499,  500,  502,  503,  504,  505,
-      506,  508,  509,  512,  515,  517,  519,  520,  521,  522,
-      523,  525,  526,  528,  529,  530,  531,  532,  533,  535,
-      536,  537,  538,  539,  540,  542,  543,  545,  546,  548,
-      549,  550,  551,  553,  554,  556,  557,  559,  560,  562,
-      564,  565,  567,  568,  569,  570,  572,  573,  575,  576,
-      578,  580,  582,  583,  585,  586,  588,  590,  591,  592,
-      594,  594
-    } ;
-
-static const YY_CHAR yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    4,    5,    1,    1,    6,    6,    7,
-        6,    6,    6,    6,    6,    6,    6,    8,    1,    1,
-        9,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,   10,   11,   12,   13,
-
-       14,   15,   16,   17,   18,   19,   20,   21,   22,   23,
-       24,   25,   26,   27,   28,   29,   30,   31,   32,   33,
-       34,   19,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static const YY_CHAR yy_meta[35] =
-    {   0,
-        1,    1,    2,    3,    1,    1,    1,    1,    4,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1
-    } ;
-
-static const flex_int16_t yy_base[443] =
-    {   0,
-        0,    0,  936,  935,  937,  932,   33,   36,  940,  940,
-       45,   63,   31,   42,   51,   52,  925,   33,   65,   67,
-       69,   70,  924,   71,  923,   75,    0,  940,  928,  940,
-       91,   95,    0,    0,  104,  921,  113,    0,   91,   99,
-      114,   92,  115,   80,  100,   48,  119,  121,  122,   74,
-      123,  128,  131,  129,  125,  133,  135,  136,  137,  143,
-      138,  145,    0,  157,    0,    0,  168,    0,    0,  926,
-      140,  146,  165,  159,  152,  164,  155,  168,  171,  176,
-      177,  170,  180,  175,  184,  188,  212,  191,  185,  192,
-      193,  194,  219,  212,  199,  230,    0,    0,  940,  195,
-
-      200,  239,  235,  197,  246,  225,  226,  919,  244,  918,
-      243,  236,  245,  266,  248,  264,  282,  271,  291,  248,
-      270,  254,  300,  279,  296,  302,  288,  303,  311,    0,
-      315,    0,  311,  318,  940,  313,  319,  208,  313,  344,
-      321,  331,  325,  333,    0,  352,    0,  345,  347,  359,
-        0,  361,    0,  368,    0,  370,    0,  322,  366,  379,
-        0,  381,    0,  359,  357,  923,  382,  384,  392,    0,
-        0,    0,    0,  387,  940,  386,  390,  392,  329,  401,
-      397,  409,    0,  417,    0,  399,  412,  426,  429,    0,
-        0,    0,    0,  412,  427,  438,    0,    0,    0,    0,
-
-      440,    0,    0,    0,    0,  436,  405,  447,    0,    0,
-        0,    0,  438,  443,  922,  940,  921,  442,  450,  449,
-      452,  454,  459,  458,  453,  469,    0,    0,    0,    0,
-      920,  470,  481,    0,  483,    0,  484,  481,  919,  368,
-      467,  495,  918,  940,  917,  940,  488,  916,  479,  490,
-      492,  495,  505,  498,  940,  915,  940,  507,  523,    0,
-        0,    0,    0,  940,  503,  864,  940,  846,  532,  836,
-        0,  824,  940,  516,  796,  940,  513,  530,  536,  538,
-      784,  940,  542,  535,  547,  772,  940,  549,  551,  768,
-      940,  502,  562,    0,  564,    0,    0,  562,  764,  940,
-
-      544,  557,  760,  752,  744,  940,  552,  568,  571,  568,
-      581,  577,  588,    0,    0,    0,    0,  589,  580,  591,
-      736,  940,  728,  940,  601,  602,  597,  599,  940,  603,
-      720,  712,  700,  672,  940,  665,  940,  610,  656,  603,
-      648,  607,  629,  940,  627,  940,  625,  940,  624,  940,
-      607,  574,  940,  614,  572,  940,  491,  940,  433,  940,
-      940,  622,  389,  940,  303,  940,  261,  940,  204,  940,
-      940,  635,  639,  642,  646,  650,  654,  658,  662,  666,
-      670,  674,  678,  682,  686,  690,  694,  698,  702,  706,
-      710,  714,  718,  722,  726,  730,  734,  738,  742,  746,
-
-      750,  754,  758,  762,  766,  770,  774,  778,  782,  786,
-      790,  794,  798,  802,  806,  810,  814,  818,  822,  826,
-      830,  834,  838,  842,  846,  850,  854,  858,  862,  866,
-      870,  874,  878,  882,  886,  890,  894,  898,  902,  906,
-      910,  914
-    } ;
-
-static const flex_int16_t yy_def[443] =
-    {   0,
-      371,    1,  372,  372,  371,  373,  374,  374,  371,  371,
-      375,  375,   12,   12,   12,   12,   12,   12,   12,   12,
-       12,   12,   12,   12,   12,   12,  376,  371,  373,  371,
-      377,  374,  378,  378,  379,   12,  373,  380,   12,   12,
-       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
-       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
-       12,   12,  376,  377,  378,  378,  381,  382,  382,  371,
-       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
-       12,   12,   12,   12,   12,   12,  379,   12,   12,   12,
-       12,   12,   12,   12,   12,  381,  382,  382,  371,   12,
-
-       12,  383,   12,   12,   12,   12,   12,   12,   12,   12,
-       12,   12,   12,  384,   87,   87,  385,   12,  386,   12,
-       12,   12,  387,   12,   12,   12,   12,   12,  388,  389,
-      383,  389,   12,   12,  371,   87,   12,   12,   12,  390,
-       12,   12,   12,  391,  392,  384,  392,   87,   87,  393,
-      394,  385,  394,  395,  396,  386,  396,   12,   12,  397,
-      398,  387,  398,   12,   12,  399,   12,   12,  388,  389,
-      389,  400,  400,   12,  371,   87,   87,   87,   12,   12,
-       12,  401,  402,  390,  402,   12,   12,  403,  391,  392,
-      392,  404,  404,   87,   87,  393,  394,  394,  405,  405,
-
-      395,  396,  396,  406,  406,   12,   12,  397,  398,  398,
-      407,  407,   12,   12,  408,  371,  409,   87,   12,   87,
-       87,   87,   12,   87,   12,  401,  402,  402,  410,  410,
-      411,   87,  412,  413,  403,  413,   87,   87,  414,   12,
-       12,  415,  408,  371,  416,  371,   87,  417,   12,   87,
-       87,   87,  418,   87,  371,  419,  371,   87,  412,  413,
-      413,  420,  420,  371,   87,  421,  371,   12,  422,  423,
-      423,  416,  371,   87,  424,  371,   12,   87,   87,   87,
-      425,  371,  425,  425,   87,  419,  371,   87,   87,  421,
-      371,   12,  426,  427,  422,  427,  423,   87,  424,  371,
-
-       12,   87,  428,  429,  425,  371,  425,  425,   87,   87,
-       87,   12,  426,  427,  427,  430,  430,   87,   12,   87,
-      431,  371,  432,  371,  425,  425,   87,   87,  371,   12,
-      433,  434,  435,  431,  371,  432,  371,  425,  425,   87,
-      436,   12,  437,  371,  438,  371,  439,  371,  425,  371,
-       87,  440,  371,   12,  437,  371,  438,  371,  439,  371,
-      371,   87,  440,  371,  441,  371,  442,  371,  442,  371,
-        0,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371
-    } ;
-
-static const flex_int16_t yy_nxt[975] =
-    {   0,
-        6,    7,    8,    9,    6,    6,    6,    6,   10,   11,
-       12,   13,   14,   15,   16,   17,   18,   19,   17,   17,
-       17,   17,   20,   17,   21,   22,   23,   24,   25,   17,
-       26,   17,   17,   17,   32,   32,   33,   32,   32,   33,
-       36,   34,   36,   42,   34,   29,   29,   29,   30,   35,
-       50,   36,   37,   38,   43,   44,   39,   36,   80,   45,
-       36,   36,   40,   29,   29,   29,   30,   35,   46,   48,
-       37,   38,   41,   47,   36,   49,   36,   53,   36,   36,
-       36,   56,   58,   36,   36,   55,   83,   61,   51,   36,
-       54,   62,   52,   29,   65,   59,   32,   32,   33,   66,
-
-       36,   36,   71,   34,   29,   29,   29,   30,   36,   36,
-       77,   29,   38,   67,   67,   67,   68,   67,   75,   72,
-       67,   69,   73,   36,   36,   74,   78,   79,   36,   53,
-       36,   36,   36,   87,   36,   76,   84,   36,   36,   85,
-       36,   81,   36,   86,   36,   36,   36,   36,   82,   36,
-       92,   95,   36,  100,   36,   36,   89,   90,   88,   29,
-       65,   36,   91,  101,   36,   66,   90,   93,   36,   94,
-       29,   97,  102,   36,   36,  104,   98,   36,  103,   36,
-       36,  107,  108,  106,   36,   36,   36,  105,   86,   36,
-      109,  110,  111,   36,   36,  114,  112,   36,  117,  119,
-
-       36,   36,   36,   36,   36,  121,   36,  368,   36,   36,
-      120,  113,   29,   29,   29,   30,  118,   36,  134,   29,
-       38,   36,  127,  115,  116,  122,  123,  125,   36,  126,
-      128,  124,   29,   97,   36,   36,  180,  138,   98,  129,
-      129,   67,  130,  129,   36,   36,  129,  132,  133,  135,
-      136,  140,   36,   36,   36,   36,  142,   36,  137,   35,
-       35,  123,   86,   36,  370,  143,  144,  144,   67,  145,
-      144,  148,  158,  144,  147,   35,   35,   90,  119,   36,
-       36,  149,  150,  150,   67,  151,  150,  159,   36,  150,
-      153,  154,  154,   67,  155,  154,  164,   36,  154,  157,
-
-      160,  160,   67,  161,  160,   36,  368,  160,  163,  165,
-      166,   36,   36,   29,  170,  167,  168,   29,  172,  171,
-       36,  175,   36,  173,   35,   35,  176,   36,   36,  177,
-       36,   36,  188,  174,   36,   29,  190,  178,   36,  181,
-       36,  191,  223,  179,  182,  182,   67,  183,  182,  186,
-      206,  182,  185,  187,   29,  192,   35,   35,   35,   35,
-      193,   29,  197,   29,  199,  194,   36,  198,   36,  200,
-       29,  202,   29,  204,  195,   36,  203,   36,  205,  268,
-      207,   29,  209,   29,  211,  214,  213,  210,  218,  212,
-      217,   36,  353,   36,   29,  170,   36,   35,   35,  219,
-
-      171,   35,   35,   35,   35,  224,   36,  231,   36,  225,
-       36,   29,  227,  221,   36,  222,  232,  228,  220,   29,
-      229,   36,  240,   35,   35,  230,  233,  233,   67,  234,
-      233,   29,  190,  233,  236,  237,  348,  191,  238,   35,
-       29,  197,   29,  202,  239,   36,  198,   36,  203,   29,
-      209,  242,   36,   35,  247,  210,  255,  241,  248,   36,
-       35,   35,   36,   35,   35,   35,   35,  253,   36,   35,
-       35,   29,  227,  250,  269,  254,   36,  228,  249,  251,
-      252,   35,  258,   29,  260,   29,  262,  264,   36,  261,
-      265,  263,   35,   35,  346,   35,   35,   70,  271,   35,
-
-       35,   35,   35,   35,   35,  274,   35,   35,  282,   35,
-       35,   36,  277,  278,   35,   35,  283,  284,   35,   35,
-      279,  285,   36,  280,  288,   29,  260,   35,   35,  289,
-      312,  261,  293,  293,   67,  294,  293,  301,  306,  293,
-      296,   35,   35,  298,  303,  306,  304,   35,   35,   35,
-       35,  309,  308,   36,  307,  282,  302,  319,   35,   35,
-       35,   35,   35,  311,   29,  314,   29,  316,   35,   35,
-      315,  282,  317,   35,   35,  344,  310,  364,  325,   35,
-       35,  318,   35,   35,  329,  320,   36,  328,  332,   36,
-       29,  314,   35,   35,  330,  326,  315,  331,  327,  333,
-
-       35,   35,   35,   35,  282,  282,  340,  341,   35,   35,
-       35,   35,   36,  282,   35,   35,   36,  351,   35,   35,
-      362,  339,  365,   36,  338,  366,  342,  361,  360,  354,
-      358,  349,  356,   35,   35,   27,   27,   27,   27,   29,
-       29,   29,   31,   31,   31,   31,   36,   36,   36,   36,
-       63,  353,   63,   63,   64,   64,   64,   64,   66,  350,
-       66,   66,   35,   35,   35,   35,   70,   70,  324,   70,
-       96,   96,   96,   96,   98,  322,   98,   98,  131,  131,
-      131,  131,  146,  146,  146,  146,  152,  152,  152,  152,
-      156,  156,  156,  156,  162,  162,  162,  162,  169,  169,
-
-      169,  169,  171,  348,  171,  171,  184,  184,  184,  184,
-      189,  189,  189,  189,  191,  346,  191,  191,  196,  196,
-      196,  196,  198,  344,  198,  198,  201,  201,  201,  201,
-      203,  337,  203,  203,  208,  208,  208,  208,  210,  335,
-      210,  210,  215,  215,  215,  215,  173,  282,  173,  173,
-      226,  226,  226,  226,  228,  324,  228,  228,  235,  235,
-      235,  235,  193,  322,  193,  193,  200,  276,  200,  200,
-      205,  267,  205,  205,  212,  257,  212,  212,  243,  243,
-      243,  243,  245,  245,  245,  245,  230,  306,  230,  230,
-      256,  256,  256,  256,  259,  259,  259,  259,  261,  300,
-
-      261,  261,  266,  266,  266,  266,  270,  270,  270,  270,
-      272,  272,  272,  272,  275,  275,  275,  275,  281,  281,
-      281,  281,  286,  286,  286,  286,  263,  246,  263,  263,
-      290,  290,  290,  290,  295,  295,  295,  295,  271,  297,
-      271,  271,  299,  299,  299,  299,  305,  305,  305,  305,
-      313,  313,  313,  313,  315,  292,  315,  315,  321,  321,
-      321,  321,  323,  323,  323,  323,  317,  291,  317,  317,
-      334,  334,  334,  334,  336,  336,  336,  336,  343,  343,
-      343,  343,  345,  345,  345,  345,  347,  347,  347,  347,
-      352,  352,  352,  352,  355,  355,  355,  355,  357,  357,
-
-      357,  357,  359,  359,  359,  359,  363,  363,  363,  363,
-      367,  367,  367,  367,  369,  369,  369,  369,  287,  276,
-      273,  216,  267,  257,  246,  244,  216,  141,  139,   99,
-       36,   30,   60,   57,   36,   30,  371,   28,   28,    5,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371
-    } ;
-
-static const flex_int16_t yy_chk[975] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    7,    7,    7,    8,    8,    8,
-       13,    7,   18,   13,    8,   11,   11,   11,   11,   11,
-       18,   14,   11,   11,   13,   14,   11,   46,   46,   14,
-       15,   16,   11,   12,   12,   12,   12,   12,   14,   16,
-       12,   12,   12,   15,   19,   16,   20,   20,   21,   22,
-       24,   22,   24,   50,   26,   21,   50,   26,   19,   44,
-       20,   26,   19,   31,   31,   24,   32,   32,   32,   31,
-
-       39,   42,   39,   32,   35,   35,   35,   35,   40,   45,
-       44,   35,   35,   37,   37,   37,   37,   37,   42,   39,
-       37,   37,   40,   41,   43,   41,   45,   45,   47,   47,
-       48,   49,   51,   54,   55,   43,   51,   52,   54,   52,
-       53,   48,   56,   53,   57,   58,   59,   61,   49,   71,
-       59,   61,   60,   71,   62,   72,   56,   62,   55,   64,
-       64,   75,   58,   72,   77,   64,   57,   60,   74,   60,
-       67,   67,   73,   76,   73,   75,   67,   78,   74,   82,
-       79,   78,   79,   77,   84,   80,   81,   76,   80,   83,
-       81,   82,   83,   85,   89,   86,   84,   86,   88,   90,
-
-       88,   90,   91,   92,  100,   92,  104,  369,   95,  101,
-       91,   85,   87,   87,   87,   87,   89,  138,  104,   87,
-       87,   94,  100,   87,   87,   93,   93,   94,   93,   95,
-      101,   93,   96,   96,  106,  107,  138,  107,   96,  102,
-      102,  102,  102,  102,  103,  112,  102,  102,  103,  105,
-      105,  109,  111,  109,  113,  105,  111,  120,  106,  115,
-      115,  122,  113,  122,  367,  112,  114,  114,  114,  114,
-      114,  115,  120,  114,  114,  116,  116,  118,  118,  121,
-      118,  116,  117,  117,  117,  117,  117,  121,  124,  117,
-      117,  119,  119,  119,  119,  119,  124,  127,  119,  119,
-
-      123,  123,  123,  123,  123,  125,  365,  123,  123,  125,
-      126,  126,  128,  129,  129,  127,  128,  131,  131,  129,
-      133,  134,  139,  131,  136,  136,  136,  134,  137,  136,
-      141,  158,  143,  133,  143,  144,  144,  136,  179,  139,
-      142,  144,  179,  137,  140,  140,  140,  140,  140,  141,
-      158,  140,  140,  142,  146,  146,  148,  148,  149,  149,
-      146,  150,  150,  152,  152,  148,  165,  150,  164,  152,
-      154,  154,  156,  156,  149,  159,  154,  240,  156,  240,
-      159,  160,  160,  162,  162,  165,  164,  160,  168,  162,
-      167,  167,  363,  168,  169,  169,  174,  176,  176,  174,
-
-      169,  177,  177,  178,  178,  180,  181,  186,  186,  181,
-      180,  182,  182,  177,  207,  178,  187,  182,  176,  184,
-      184,  187,  207,  194,  194,  184,  188,  188,  188,  188,
-      188,  189,  189,  188,  188,  194,  359,  189,  195,  195,
-      196,  196,  201,  201,  206,  206,  196,  213,  201,  208,
-      208,  214,  214,  218,  218,  208,  225,  213,  219,  219,
-      220,  220,  225,  221,  221,  222,  222,  223,  223,  224,
-      224,  226,  226,  220,  241,  224,  241,  226,  219,  221,
-      222,  232,  232,  233,  233,  235,  235,  237,  249,  233,
-      238,  235,  238,  238,  357,  237,  237,  242,  242,  247,
-
-      247,  250,  250,  251,  251,  247,  252,  252,  253,  254,
-      254,  292,  249,  250,  265,  265,  253,  253,  258,  258,
-      251,  254,  277,  252,  258,  259,  259,  274,  274,  265,
-      292,  259,  269,  269,  269,  269,  269,  277,  284,  269,
-      269,  278,  278,  274,  279,  283,  280,  279,  279,  280,
-      280,  285,  284,  301,  283,  307,  278,  301,  285,  285,
-      288,  288,  289,  289,  293,  293,  295,  295,  302,  302,
-      293,  308,  295,  298,  298,  355,  288,  352,  307,  310,
-      310,  298,  309,  309,  311,  302,  312,  310,  319,  319,
-      313,  313,  311,  311,  312,  308,  313,  318,  309,  320,
-
-      318,  318,  320,  320,  325,  326,  327,  328,  327,  327,
-      328,  328,  330,  338,  340,  340,  342,  340,  351,  351,
-      351,  326,  354,  354,  325,  362,  330,  349,  347,  342,
-      345,  338,  343,  362,  362,  372,  372,  372,  372,  373,
-      373,  373,  374,  374,  374,  374,  375,  375,  375,  375,
-      376,  341,  376,  376,  377,  377,  377,  377,  378,  339,
-      378,  378,  379,  379,  379,  379,  380,  380,  336,  380,
-      381,  381,  381,  381,  382,  334,  382,  382,  383,  383,
-      383,  383,  384,  384,  384,  384,  385,  385,  385,  385,
-      386,  386,  386,  386,  387,  387,  387,  387,  388,  388,
-
-      388,  388,  389,  333,  389,  389,  390,  390,  390,  390,
-      391,  391,  391,  391,  392,  332,  392,  392,  393,  393,
-      393,  393,  394,  331,  394,  394,  395,  395,  395,  395,
-      396,  323,  396,  396,  397,  397,  397,  397,  398,  321,
-      398,  398,  399,  399,  399,  399,  400,  305,  400,  400,
-      401,  401,  401,  401,  402,  304,  402,  402,  403,  403,
-      403,  403,  404,  303,  404,  404,  405,  299,  405,  405,
-      406,  290,  406,  406,  407,  286,  407,  407,  408,  408,
-      408,  408,  409,  409,  409,  409,  410,  281,  410,  410,
-      411,  411,  411,  411,  412,  412,  412,  412,  413,  275,
-
-      413,  413,  414,  414,  414,  414,  415,  415,  415,  415,
-      416,  416,  416,  416,  417,  417,  417,  417,  418,  418,
-      418,  418,  419,  419,  419,  419,  420,  272,  420,  420,
-      421,  421,  421,  421,  422,  422,  422,  422,  423,  270,
-      423,  423,  424,  424,  424,  424,  425,  425,  425,  425,
-      426,  426,  426,  426,  427,  268,  427,  427,  428,  428,
-      428,  428,  429,  429,  429,  429,  430,  266,  430,  430,
-      431,  431,  431,  431,  432,  432,  432,  432,  433,  433,
-      433,  433,  434,  434,  434,  434,  435,  435,  435,  435,
-      436,  436,  436,  436,  437,  437,  437,  437,  438,  438,
-
-      438,  438,  439,  439,  439,  439,  440,  440,  440,  440,
-      441,  441,  441,  441,  442,  442,  442,  442,  256,  248,
-      245,  243,  239,  231,  217,  215,  166,  110,  108,   70,
-       36,   29,   25,   23,   17,    6,    5,    4,    3,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371,  371,  371,  371,  371,  371,  371,
-      371,  371,  371,  371
-    } ;
-
-#define YY_TRAILING_MASK 0x2000
-#define YY_TRAILING_HEAD_MASK 0x4000
-#define REJECT \
-{ \
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */ \
-yy_cp = yyg->yy_full_match; /* restore poss. backed-over text */ \
-yyg->yy_lp = yyg->yy_full_lp; /* restore orig. accepting pos. */ \
-yyg->yy_state_ptr = yyg->yy_full_state; /* restore orig. state */ \
-yy_current_state = *yyg->yy_state_ptr; /* restore curr. state */ \
-++yyg->yy_lp; \
-goto find_rule; \
-}
-
-#define yymore() (yyg->yy_more_flag = 1)
-#define YY_MORE_ADJ yyg->yy_more_len
-#define YY_RESTORE_YY_MORE_OFFSET
-#line 1 "libxlu_disk_l.l"
-/* -*- fundamental -*- */
-/*
- * libxlu_disk_l.l - parser for disk specification strings
- *
- * Copyright (C) 2011      Citrix Ltd.
- * Author Ian Jackson <ian.jackson@eu.citrix.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published
- * by the Free Software Foundation; version 2.1 only. with the special
- * exception on linking described in file LICENSE.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- */
-/*
- * Parsing the old xm/xend/xl-4.1 disk specs is a tricky problem,
- * because the target string might in theory contain "," which is the
- * delimiter we use for stripping off things on the RHS, and ":",
- * which is the delimiter we use for stripping off things on the LHS.
- *
- * In this parser we do not support such target strings in the old
- * syntax; if the target string has to contain "," or ":" the new
- * syntax's "target=" should be used.
- */
-
-#line 35 "libxlu_disk_l.l"
-#include "libxlu_disk_i.h"
-
-#define YY_NO_INPUT
-
-/* The code generated by flex is missing braces in single line expressions and
- * is not properly indented, which triggers the clang misleading-indentation
- * check that has been made part of -Wall since clang 10. In order to safely
- * disable it on clang versions that don't have the diagnostic implemented
- * also disable the unknown option and pragma warning. */
-#ifdef __clang__
-# pragma clang diagnostic ignored "-Wunknown-pragmas"
-# pragma clang diagnostic ignored "-Wunknown-warning-option"
-# pragma clang diagnostic ignored "-Wmisleading-indentation"
-#endif
-
-/* Some versions of flex have a bug (Fedora bugzilla 612465) which causes
- * it to fail to declare these functions, which it defines.  So declare
- * them ourselves.  Hopefully we won't have to simultaneously support
- * a flex version which declares these differently somehow. */
-int xlu__disk_yyget_column(yyscan_t yyscanner);
-void xlu__disk_yyset_column(int  column_no, yyscan_t yyscanner);
-
-
-/*----- useful macros and functions used in actions -----
- * we use macros in the actual rules to keep the actions short
- * and particularly to avoid repeating boilerplate values such as
- * DPC->disk, yytext, etc. */
-
-/* Sets an enum, checking it hasn't already been set to a different value  */
-#define DSET(dpc,member,enumname,str,valname) do{			\
-	if (dpc->disk->member != LIBXL_DISK_##enumname##_UNKNOWN &&	\
-	    dpc->disk->member != LIBXL_DISK_##enumname##_##valname) {	\
-	    xlu__disk_err(dpc, str, TOSTRING(member) " respecified");	\
-	} else {							\
-	    dpc->disk->member = LIBXL_DISK_##enumname##_##valname;	\
-	}								\
-    }while(0)
-
-/* For actions whose patterns contain '=', finds the start of the value */
-#define FROMEQUALS (strchr(yytext,'=')+1)
-
-/* Chops the delimiter off, modifying yytext and yyleng. */
-#define STRIP(delim) do{                                                \
-	if (yyleng>0 && yytext[yyleng-1]==(delim))                      \
-	    yytext[--yyleng] = 0;                                       \
-    }while(0)
-
-/* Sets a string value, checking it hasn't been set already. */
-#define SAVESTRING(what,loc,val) do{					\
-	savestring(DPC, what " respecified", &DPC->disk->loc, (val));	\
-    }while(0)
-static void savestring(DiskParseContext *dpc, const char *what_respecified,
-		       char **update, const char *value) {
-    if (*update) {
-        if (**update) { xlu__disk_err(dpc,value,what_respecified); return; }
-        free(*update); /* do not complain about overwriting empty strings */
-    }
-    *update = strdup(value);
-}
-
-#define DPC dpc /* our convention in lexer helper functions */
-
-/* Sets ->readwrite from the string.  This ought to be an enum, perhaps. */
-static void setaccess(DiskParseContext *dpc, const char *str) {
-    if (!strcmp(str, "r") || !strcmp(str, "ro")) {
-        dpc->disk->readwrite = 0;
-    } else if (!strcmp(str, "rw") || !strcmp(str, "w") || !strcmp(str,"")) {
-	dpc->disk->readwrite = 1;
-    } else {
-	xlu__disk_err(dpc,str,"unknown value for access");
-    }
-}
-
-/* Sets ->format from the string.  IDL should provide something for this. */
-static void setformat(DiskParseContext *dpc, const char *str) {
-    if      (!strcmp(str,""))       DSET(dpc,format,FORMAT,str,RAW);
-    else if (!strcmp(str,"raw"))    DSET(dpc,format,FORMAT,str,RAW);
-    else if (!strcmp(str,"qcow"))   DSET(dpc,format,FORMAT,str,QCOW);
-    else if (!strcmp(str,"qcow2"))  DSET(dpc,format,FORMAT,str,QCOW2);
-    else if (!strcmp(str,"vhd"))    DSET(dpc,format,FORMAT,str,VHD);
-    else if (!strcmp(str,"empty"))  DSET(dpc,format,FORMAT,str,EMPTY);
-    else if (!strcmp(str,"qed"))    DSET(dpc,format,FORMAT,str,QED);
-    else xlu__disk_err(dpc,str,"unknown value for format");
-}
-
-/* Sets ->backend from the string.  IDL should provide something for this. */
-static void setbackendtype(DiskParseContext *dpc, const char *str) {
-    if (     !strcmp(str,"phy"))   DSET(dpc,backend,BACKEND,str,PHY);
-    else if (!strcmp(str,"tap"))   DSET(dpc,backend,BACKEND,str,TAP);
-    else if (!strcmp(str,"qdisk")) DSET(dpc,backend,BACKEND,str,QDISK);
-    else if (!strcmp(str,"standalone")) DSET(dpc,backend,BACKEND,str,STANDALONE);
-    else xlu__disk_err(dpc,str,"unknown value for backendtype");
-}
-
-/* Sets ->specification from the string.  IDL should provide something for this. */
-static void setspecification(DiskParseContext *dpc, const char *str) {
-    if      (!strcmp(str,"xen"))    DSET(dpc,specification,SPECIFICATION,str,XEN);
-    else if (!strcmp(str,"virtio")) DSET(dpc,specification,SPECIFICATION,str,VIRTIO);
-    else xlu__disk_err(dpc,str,"unknown value for specification");
-}
-
-/* Sets ->colo-port from the string.  COLO need this. */
-static void setcoloport(DiskParseContext *dpc, const char *str) {
-    int port = atoi(str);
-    if (port) {
-       dpc->disk->colo_port = port;
-    } else {
-	xlu__disk_err(dpc,str,"unknown value for colo_port");
-    }
-}
-
-#define DEPRECATE(usewhatinstead) /* not currently reported */
-
-/* Handles a vdev positional parameter which includes a devtype. */
-static int vdev_and_devtype(DiskParseContext *dpc, char *str) {
-    /* returns 1 if it was <vdev>:<devtype>, 0 (doing nothing) otherwise */
-    char *colon = strrchr(str, ':');
-    if (!colon)
-        return 0;
-
-    DEPRECATE("use `devtype=...'");
-    *colon++ = 0;
-    SAVESTRING("vdev", vdev, str);
-
-    if (!strcmp(colon,"cdrom")) {
-        DPC->disk->is_cdrom = 1;
-    } else if (!strcmp(colon,"disk")) {
-        DPC->disk->is_cdrom = 0;
-    } else {
-        xlu__disk_err(DPC,colon,"unknown deprecated type");
-    }
-    return 1;
-}
-
-#undef DPC /* needs to be defined differently the actual lexer */
-#define DPC ((DiskParseContext*)yyextra)
-
-#line 1227 "libxlu_disk_l.c"
-
-#line 1229 "libxlu_disk_l.c"
-
-#define INITIAL 0
-#define LEXERR 1
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-/* Holds the entire state of the reentrant scanner. */
-struct yyguts_t
-    {
-
-    /* User-defined. Not touched by flex. */
-    YY_EXTRA_TYPE yyextra_r;
-
-    /* The rest are the same as the globals declared in the non-reentrant scanner. */
-    FILE *yyin_r, *yyout_r;
-    size_t yy_buffer_stack_top; /**< index of top of stack. */
-    size_t yy_buffer_stack_max; /**< capacity of stack. */
-    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
-    char yy_hold_char;
-    int yy_n_chars;
-    int yyleng_r;
-    char *yy_c_buf_p;
-    int yy_init;
-    int yy_start;
-    int yy_did_buffer_switch_on_eof;
-    int yy_start_stack_ptr;
-    int yy_start_stack_depth;
-    int *yy_start_stack;
-    yy_state_type yy_last_accepting_state;
-    char* yy_last_accepting_cpos;
-
-    int yylineno_r;
-    int yy_flex_debug_r;
-
-    yy_state_type *yy_state_buf;
-    yy_state_type *yy_state_ptr;
-    char *yy_full_match;
-    int yy_lp;
-
-    /* These are only needed for trailing context rules,
-     * but there's no conditional variable for that yet. */
-    int yy_looking_for_trail_begin;
-    int yy_full_lp;
-    int *yy_full_state;
-
-    char *yytext_r;
-    int yy_more_flag;
-    int yy_more_len;
-
-    }; /* end struct yyguts_t */
-
-static int yy_init_globals ( yyscan_t yyscanner );
-
-int yylex_init (yyscan_t* scanner);
-
-int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy ( yyscan_t yyscanner );
-
-int yyget_debug ( yyscan_t yyscanner );
-
-void yyset_debug ( int debug_flag , yyscan_t yyscanner );
-
-YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );
-
-void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );
-
-FILE *yyget_in ( yyscan_t yyscanner );
-
-void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );
-
-FILE *yyget_out ( yyscan_t yyscanner );
-
-void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );
-
-			int yyget_leng ( yyscan_t yyscanner );
-
-char *yyget_text ( yyscan_t yyscanner );
-
-int yyget_lineno ( yyscan_t yyscanner );
-
-void yyset_lineno ( int _line_number , yyscan_t yyscanner );
-
-int yyget_column  ( yyscan_t yyscanner );
-
-void yyset_column ( int _column_no , yyscan_t yyscanner );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap ( yyscan_t yyscanner );
-#else
-extern int yywrap ( yyscan_t yyscanner );
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-    
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput ( yyscan_t yyscanner );
-#else
-static int input ( yyscan_t yyscanner );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k */
-#define YY_READ_BUF_SIZE 16384
-#else
-#define YY_READ_BUF_SIZE 8192
-#endif /* __ia64__ */
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		int n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (yyscan_t yyscanner);
-
-#define YY_DECL int yylex (yyscan_t yyscanner)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK /*LINTED*/break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	yy_state_type yy_current_state;
-	char *yy_cp, *yy_bp;
-	int yy_act;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if ( !yyg->yy_init )
-		{
-		yyg->yy_init = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-        /* Create the reject buffer large enough to save one state per allowed character. */
-        if ( ! yyg->yy_state_buf )
-            yyg->yy_state_buf = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  , yyscanner);
-            if ( ! yyg->yy_state_buf )
-                YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
-
-		if ( ! yyg->yy_start )
-			yyg->yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack (yyscanner);
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
-		}
-
-		yy_load_buffer_state( yyscanner );
-		}
-
-	{
-#line 185 "libxlu_disk_l.l"
-
-
-#line 188 "libxlu_disk_l.l"
- /*----- the scanner rules which do the parsing -----*/
-
-#line 1511 "libxlu_disk_l.c"
-
-	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
-		{
-		yyg->yy_more_len = 0;
-		if ( yyg->yy_more_flag )
-			{
-			yyg->yy_more_len = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
-			yyg->yy_more_flag = 0;
-			}
-		yy_cp = yyg->yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yyg->yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yyg->yy_start;
-
-		yyg->yy_state_ptr = yyg->yy_state_buf;
-		*yyg->yy_state_ptr++ = yy_current_state;
-
-yy_match:
-		do
-			{
-			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 372 )
-					yy_c = yy_meta[yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-			*yyg->yy_state_ptr++ = yy_current_state;
-			++yy_cp;
-			}
-		while ( yy_current_state != 371 );
-
-yy_find_action:
-		yy_current_state = *--yyg->yy_state_ptr;
-		yyg->yy_lp = yy_accept[yy_current_state];
-find_rule: /* we branch to this label when backing up */
-		for ( ; ; ) /* until we find what rule we matched */
-			{
-			if ( yyg->yy_lp && yyg->yy_lp < yy_accept[yy_current_state + 1] )
-				{
-				yy_act = yy_acclist[yyg->yy_lp];
-				if ( yy_act & YY_TRAILING_HEAD_MASK ||
-				     yyg->yy_looking_for_trail_begin )
-					{
-					if ( yy_act == yyg->yy_looking_for_trail_begin )
-						{
-						yyg->yy_looking_for_trail_begin = 0;
-						yy_act &= ~YY_TRAILING_HEAD_MASK;
-						break;
-						}
-					}
-				else if ( yy_act & YY_TRAILING_MASK )
-					{
-					yyg->yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;
-					yyg->yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;
-					}
-				else
-					{
-					yyg->yy_full_match = yy_cp;
-					yyg->yy_full_state = yyg->yy_state_ptr;
-					yyg->yy_full_lp = yyg->yy_lp;
-					break;
-					}
-				++yyg->yy_lp;
-				goto find_rule;
-				}
-			--yy_cp;
-			yy_current_state = *--yyg->yy_state_ptr;
-			yyg->yy_lp = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-case 1:
-/* rule 1 can match eol */
-YY_RULE_SETUP
-#line 190 "libxlu_disk_l.l"
-{ /* ignore whitespace before parameters */ }
-	YY_BREAK
-/* ordinary parameters setting enums or strings */
-case 2:
-/* rule 2 can match eol */
-YY_RULE_SETUP
-#line 194 "libxlu_disk_l.l"
-{ STRIP(','); setformat(DPC, FROMEQUALS); }
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 196 "libxlu_disk_l.l"
-{ DPC->disk->is_cdrom = 1; }
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 197 "libxlu_disk_l.l"
-{ DPC->disk->is_cdrom = 1; }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 198 "libxlu_disk_l.l"
-{ DPC->disk->is_cdrom = 0; }
-	YY_BREAK
-case 6:
-/* rule 6 can match eol */
-YY_RULE_SETUP
-#line 199 "libxlu_disk_l.l"
-{ xlu__disk_err(DPC,yytext,"unknown value for type"); }
-	YY_BREAK
-case 7:
-/* rule 7 can match eol */
-YY_RULE_SETUP
-#line 201 "libxlu_disk_l.l"
-{ STRIP(','); setaccess(DPC, FROMEQUALS); }
-	YY_BREAK
-case 8:
-/* rule 8 can match eol */
-YY_RULE_SETUP
-#line 202 "libxlu_disk_l.l"
-{ STRIP(','); SAVESTRING("backend", backend_domname, FROMEQUALS); }
-	YY_BREAK
-case 9:
-/* rule 9 can match eol */
-YY_RULE_SETUP
-#line 203 "libxlu_disk_l.l"
-{ STRIP(','); setbackendtype(DPC,FROMEQUALS); }
-	YY_BREAK
-case 10:
-/* rule 10 can match eol */
-YY_RULE_SETUP
-#line 204 "libxlu_disk_l.l"
-{ STRIP(','); setspecification(DPC,FROMEQUALS); }
-	YY_BREAK
-case 11:
-/* rule 11 can match eol */
-YY_RULE_SETUP
-#line 206 "libxlu_disk_l.l"
-{ STRIP(','); SAVESTRING("vdev", vdev, FROMEQUALS); }
-	YY_BREAK
-case 12:
-/* rule 12 can match eol */
-YY_RULE_SETUP
-#line 207 "libxlu_disk_l.l"
-{ STRIP(','); SAVESTRING("script", script, FROMEQUALS); }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 208 "libxlu_disk_l.l"
-{ DPC->disk->direct_io_safe = 1; }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 209 "libxlu_disk_l.l"
-{ libxl_defbool_set(&DPC->disk->discard_enable, true); }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 210 "libxlu_disk_l.l"
-{ libxl_defbool_set(&DPC->disk->discard_enable, false); }
-	YY_BREAK
-/* Note that the COLO configuration settings should be considered unstable.
-  * They may change incompatibly in future versions of Xen. */
-case 16:
-YY_RULE_SETUP
-#line 213 "libxlu_disk_l.l"
-{ libxl_defbool_set(&DPC->disk->colo_enable, true); }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 214 "libxlu_disk_l.l"
-{ libxl_defbool_set(&DPC->disk->colo_enable, false); }
-	YY_BREAK
-case 18:
-/* rule 18 can match eol */
-YY_RULE_SETUP
-#line 215 "libxlu_disk_l.l"
-{ STRIP(','); SAVESTRING("colo-host", colo_host, FROMEQUALS); }
-	YY_BREAK
-case 19:
-/* rule 19 can match eol */
-YY_RULE_SETUP
-#line 216 "libxlu_disk_l.l"
-{ STRIP(','); setcoloport(DPC, FROMEQUALS); }
-	YY_BREAK
-case 20:
-/* rule 20 can match eol */
-YY_RULE_SETUP
-#line 217 "libxlu_disk_l.l"
-{ STRIP(','); SAVESTRING("colo-export", colo_export, FROMEQUALS); }
-	YY_BREAK
-case 21:
-/* rule 21 can match eol */
-YY_RULE_SETUP
-#line 218 "libxlu_disk_l.l"
-{ STRIP(','); SAVESTRING("active-disk", active_disk, FROMEQUALS); }
-	YY_BREAK
-case 22:
-/* rule 22 can match eol */
-YY_RULE_SETUP
-#line 219 "libxlu_disk_l.l"
-{ STRIP(','); SAVESTRING("hidden-disk", hidden_disk, FROMEQUALS); }
-	YY_BREAK
-/* the target magic parameter, eats the rest of the string */
-case 23:
-YY_RULE_SETUP
-#line 223 "libxlu_disk_l.l"
-{ STRIP(','); SAVESTRING("target", pdev_path, FROMEQUALS); }
-	YY_BREAK
-/* unknown parameters */
-case 24:
-/* rule 24 can match eol */
-YY_RULE_SETUP
-#line 227 "libxlu_disk_l.l"
-{ xlu__disk_err(DPC,yytext,"unknown parameter"); }
-	YY_BREAK
-/* deprecated prefixes */
-/* the "/.*" in these patterns ensures that they count as if they
-   * matched the whole string, so these patterns take precedence */
-case 25:
-YY_RULE_SETUP
-#line 234 "libxlu_disk_l.l"
-{
-                    STRIP(':');
-                    DPC->had_depr_prefix=1; DEPRECATE("use `[format=]...,'");
-                    setformat(DPC, yytext);
-                 }
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 240 "libxlu_disk_l.l"
-{
-                    char *newscript;
-                    STRIP(':');
-                    DPC->had_depr_prefix=1; DEPRECATE("use `script=...'");
-                    if (asprintf(&newscript, "block-%s", yytext) < 0) {
-                            xlu__disk_err(DPC,yytext,"unable to format script");
-                            return 0;
-                    }
-                    savestring(DPC, "script respecified",
-                               &DPC->disk->script, newscript);
-                    free(newscript);
-                }
-	YY_BREAK
-case 27:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 8;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 253 "libxlu_disk_l.l"
-{ DPC->had_depr_prefix=1; DEPRECATE(0); }
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 254 "libxlu_disk_l.l"
-{ DPC->had_depr_prefix=1; DEPRECATE(0); }
-	YY_BREAK
-case 29:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 4;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 255 "libxlu_disk_l.l"
-{ DPC->had_depr_prefix=1; DEPRECATE(0); }
-	YY_BREAK
-case 30:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 6;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 256 "libxlu_disk_l.l"
-{ DPC->had_depr_prefix=1; DEPRECATE(0); }
-	YY_BREAK
-case 31:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 257 "libxlu_disk_l.l"
-{ DPC->had_depr_prefix=1; DEPRECATE(0); }
-	YY_BREAK
-case 32:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 4;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 258 "libxlu_disk_l.l"
-{ DPC->had_depr_prefix=1; DEPRECATE(0); }
-	YY_BREAK
-case 33:
-/* rule 33 can match eol */
-YY_RULE_SETUP
-#line 260 "libxlu_disk_l.l"
-{
-		  xlu__disk_err(DPC,yytext,"unknown deprecated disk prefix");
-		  return 0;
-		}
-	YY_BREAK
-/* positional parameters */
-case 34:
-/* rule 34 can match eol */
-YY_RULE_SETUP
-#line 267 "libxlu_disk_l.l"
-{
-    STRIP(',');
-
-    if (DPC->err) {
-        /* previous errors may just lead to subsequent ones */
-    } else if (!DPC->disk->pdev_path) {
-        SAVESTRING("target", pdev_path, yytext);
-    } else if (!DPC->had_depr_prefix &&
-               DPC->disk->format == LIBXL_DISK_FORMAT_UNKNOWN) {
-        if (!*DPC->disk->pdev_path && vdev_and_devtype(DPC,yytext)) {
-            DPC->disk->format = LIBXL_DISK_FORMAT_EMPTY;
-        } else {
-            setformat(DPC,yytext);
-        }
-    } else if (!DPC->disk->vdev) {
-        if (!vdev_and_devtype(DPC,yytext))
-            SAVESTRING("vdev", vdev, yytext);
-    } else if (!DPC->access_set) {
-        DPC->access_set = 1;
-        setaccess(DPC,yytext);
-    } else {
-        xlu__disk_err(DPC,yytext,"too many positional parameters");
-        return 0; /* don't print any more errors */
-    }
-}
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 293 "libxlu_disk_l.l"
-{
-    BEGIN(LEXERR);
-    yymore();
-}
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 297 "libxlu_disk_l.l"
-{
-    xlu__disk_err(DPC,yytext,"bad disk syntax"); return 0;
-}
-	YY_BREAK
-case 37:
-YY_RULE_SETUP
-#line 300 "libxlu_disk_l.l"
-YY_FATAL_ERROR( "flex scanner jammed" );
-	YY_BREAK
-#line 1870 "libxlu_disk_l.c"
-			case YY_STATE_EOF(INITIAL):
-			case YY_STATE_EOF(LEXERR):
-				yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yyg->yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state( yyscanner );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);
-
-			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yyg->yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yyg->yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer( yyscanner ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yyg->yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap( yyscanner ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yyg->yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yyg->yy_c_buf_p =
-					yyg->yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state( yyscanner );
-
-				yy_cp = yyg->yy_c_buf_p;
-				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yyg->yy_c_buf_p =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];
-
-				yy_current_state = yy_get_previous_state( yyscanner );
-
-				yy_cp = yyg->yy_c_buf_p;
-				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of user's declarations */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	char *source = yyg->yytext_ptr;
-	int number_to_move, i;
-	int ret_val;
-
-	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;
-
-	else
-		{
-			int num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			yyg->yy_n_chars, num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
-		}
-
-	if ( yyg->yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin  , yyscanner);
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
-			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-		/* "- 2" to take care of EOB's */
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
-	}
-
-	yyg->yy_n_chars += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
-{
-	yy_state_type yy_current_state;
-	char *yy_cp;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	yy_current_state = yyg->yy_start;
-
-	yyg->yy_state_ptr = yyg->yy_state_buf;
-	*yyg->yy_state_ptr++ = yy_current_state;
-
-	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
-		{
-		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 372 )
-				yy_c = yy_meta[yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-		*yyg->yy_state_ptr++ = yy_current_state;
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
-{
-	int yy_is_jam;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
-
-	YY_CHAR yy_c = 1;
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 372 )
-			yy_c = yy_meta[yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-	yy_is_jam = (yy_current_state == 371);
-	if ( ! yy_is_jam )
-		*yyg->yy_state_ptr++ = yy_current_state;
-
-	(void)yyg;
-	return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_UNPUT
-
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (yyscan_t yyscanner)
-#else
-    static int input  (yyscan_t yyscanner)
-#endif
-
-{
-	int c;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	*yyg->yy_c_buf_p = yyg->yy_hold_char;
-
-	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
-			/* This was really a NUL. */
-			*yyg->yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
-			++yyg->yy_c_buf_p;
-
-			switch ( yy_get_next_buffer( yyscanner ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin , yyscanner);
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap( yyscanner ) )
-						return 0;
-
-					if ( ! yyg->yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput(yyscanner);
-#else
-					return input(yyscanner);
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
-	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
-	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * @param yyscanner The scanner object.
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack (yyscanner);
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
-	}
-
-	yy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);
-	yy_load_buffer_state( yyscanner );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * @param yyscanner The scanner object.
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack (yyscanner);
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*yyg->yy_c_buf_p = yyg->yy_hold_char;
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( yyscanner );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yyg->yy_did_buffer_switch_on_eof = 1;
-}
-
-static void yy_load_buffer_state  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	yyg->yy_hold_char = *yyg->yy_c_buf_p;
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * @param yyscanner The scanner object.
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file , yyscanner);
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * @param yyscanner The scanner object.
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree( (void *) b->yy_ch_buf , yyscanner );
-
-	yyfree( (void *) b , yyscanner );
-}
-
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)
-
-{
-	int oerrno = errno;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	yy_flush_buffer( b , yyscanner);
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * @param yyscanner The scanner object.
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( yyscanner );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  @param yyscanner The scanner object.
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack(yyscanner);
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*yyg->yy_c_buf_p = yyg->yy_hold_char;
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		yyg->yy_buffer_stack_top++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( yyscanner );
-	yyg->yy_did_buffer_switch_on_eof = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  @param yyscanner The scanner object.
- */
-void yypop_buffer_state (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if (yyg->yy_buffer_stack_top > 0)
-		--yyg->yy_buffer_stack_top;
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( yyscanner );
-		yyg->yy_did_buffer_switch_on_eof = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (yyscan_t yyscanner)
-{
-	yy_size_t num_to_alloc;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if (!yyg->yy_buffer_stack) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
-		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								, yyscanner);
-		if ( ! yyg->yy_buffer_stack )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-
-		yyg->yy_buffer_stack_max = num_to_alloc;
-		yyg->yy_buffer_stack_top = 0;
-		return;
-	}
-
-	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		yy_size_t grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
-		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
-								(yyg->yy_buffer_stack,
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								, yyscanner);
-		if ( ! yyg->yy_buffer_stack )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
-		yyg->yy_buffer_stack_max = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return NULL;
-
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = NULL;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b , yyscanner );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
-{
-    
-	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param yybytes the byte buffer to scan
- * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
- * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = (yy_size_t) (_yybytes_len + 2);
-	buf = (char *) yyalloc( n , yyscanner );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n , yyscanner);
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-	fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = yyg->yy_hold_char; \
-		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
-		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
-		*yyg->yy_c_buf_p = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the user-defined data for this scanner.
- * @param yyscanner The scanner object.
- */
-YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyextra;
-}
-
-/** Get the current line number.
- * @param yyscanner The scanner object.
- */
-int yyget_lineno  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        if (! YY_CURRENT_BUFFER)
-            return 0;
-    
-    return yylineno;
-}
-
-/** Get the current column number.
- * @param yyscanner The scanner object.
- */
-int yyget_column  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        if (! YY_CURRENT_BUFFER)
-            return 0;
-    
-    return yycolumn;
-}
-
-/** Get the input stream.
- * @param yyscanner The scanner object.
- */
-FILE *yyget_in  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyin;
-}
-
-/** Get the output stream.
- * @param yyscanner The scanner object.
- */
-FILE *yyget_out  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyout;
-}
-
-/** Get the length of the current token.
- * @param yyscanner The scanner object.
- */
-int yyget_leng  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyleng;
-}
-
-/** Get the current token.
- * @param yyscanner The scanner object.
- */
-
-char *yyget_text  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yytext;
-}
-
-/** Set the user-defined data. This data is never touched by the scanner.
- * @param user_defined The data to be associated with this scanner.
- * @param yyscanner The scanner object.
- */
-void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyextra = user_defined ;
-}
-
-/** Set the current line number.
- * @param _line_number line number
- * @param yyscanner The scanner object.
- */
-void yyset_lineno (int  _line_number , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        /* lineno is only valid if an input buffer exists. */
-        if (! YY_CURRENT_BUFFER )
-           YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
-    
-    yylineno = _line_number;
-}
-
-/** Set the current column.
- * @param _column_no column number
- * @param yyscanner The scanner object.
- */
-void yyset_column (int  _column_no , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        /* column is only valid if an input buffer exists. */
-        if (! YY_CURRENT_BUFFER )
-           YY_FATAL_ERROR( "yyset_column called with no buffer" );
-    
-    yycolumn = _column_no;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param _in_str A readable stream.
- * @param yyscanner The scanner object.
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  _in_str , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyin = _in_str ;
-}
-
-void yyset_out (FILE *  _out_str , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyout = _out_str ;
-}
-
-int yyget_debug  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yy_flex_debug;
-}
-
-void yyset_debug (int  _bdebug , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yy_flex_debug = _bdebug ;
-}
-
-/* Accessor methods for yylval and yylloc */
-
-/* User-visible API */
-
-/* yylex_init is special because it creates the scanner itself, so it is
- * the ONLY reentrant function that doesn't take the scanner as the last argument.
- * That's why we explicitly handle the declaration, instead of using our macros.
- */
-int yylex_init(yyscan_t* ptr_yy_globals)
-{
-    if (ptr_yy_globals == NULL){
-        errno = EINVAL;
-        return 1;
-    }
-
-    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );
-
-    if (*ptr_yy_globals == NULL){
-        errno = ENOMEM;
-        return 1;
-    }
-
-    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
-    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-
-    return yy_init_globals ( *ptr_yy_globals );
-}
-
-/* yylex_init_extra has the same functionality as yylex_init, but follows the
- * convention of taking the scanner as the last argument. Note however, that
- * this is a *pointer* to a scanner, as it will be allocated by this call (and
- * is the reason, too, why this function also must handle its own declaration).
- * The user defined value in the first argument will be available to yyalloc in
- * the yyextra field.
- */
-int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )
-{
-    struct yyguts_t dummy_yyguts;
-
-    yyset_extra (yy_user_defined, &dummy_yyguts);
-
-    if (ptr_yy_globals == NULL){
-        errno = EINVAL;
-        return 1;
-    }
-
-    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-
-    if (*ptr_yy_globals == NULL){
-        errno = ENOMEM;
-        return 1;
-    }
-
-    /* By setting to 0xAA, we expose bugs in
-    yy_init_globals. Leave at 0x00 for releases. */
-    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-
-    yyset_extra (yy_user_defined, *ptr_yy_globals);
-
-    return yy_init_globals ( *ptr_yy_globals );
-}
-
-static int yy_init_globals (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    yyg->yy_buffer_stack = NULL;
-    yyg->yy_buffer_stack_top = 0;
-    yyg->yy_buffer_stack_max = 0;
-    yyg->yy_c_buf_p = NULL;
-    yyg->yy_init = 0;
-    yyg->yy_start = 0;
-
-    yyg->yy_start_stack_ptr = 0;
-    yyg->yy_start_stack_depth = 0;
-    yyg->yy_start_stack =  NULL;
-
-    yyg->yy_state_buf = 0;
-    yyg->yy_state_ptr = 0;
-    yyg->yy_full_match = 0;
-    yyg->yy_lp = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = NULL;
-    yyout = NULL;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state(yyscanner);
-	}
-
-	/* Destroy the stack itself. */
-	yyfree(yyg->yy_buffer_stack , yyscanner);
-	yyg->yy_buffer_stack = NULL;
-
-    /* Destroy the start condition stack. */
-        yyfree( yyg->yy_start_stack , yyscanner );
-        yyg->yy_start_stack = NULL;
-
-    yyfree ( yyg->yy_state_buf , yyscanner);
-    yyg->yy_state_buf  = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( yyscanner);
-
-    /* Destroy the main struct (reentrant only). */
-    yyfree ( yyscanner , yyscanner );
-    yyscanner = NULL;
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-
-	int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
-{
-	int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-	return malloc(size);
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return realloc(ptr, size);
-}
-
-void yyfree (void * ptr , yyscan_t yyscanner)
-{
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 300 "libxlu_disk_l.l"
diff --git a/tools/libs/util/libxlu_disk_l.h b/tools/libs/util/libxlu_disk_l.h
deleted file mode 100644
index 509aad67dc..0000000000
--- a/tools/libs/util/libxlu_disk_l.h
+++ /dev/null
@@ -1,701 +0,0 @@
-#ifndef xlu__disk_yyHEADER_H
-#define xlu__disk_yyHEADER_H 1
-#define xlu__disk_yyIN_HEADER 1
-
-#line 5 "libxlu_disk_l.h"
-#define _GNU_SOURCE
-
-#line 8 "libxlu_disk_l.h"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 4
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-#ifdef yy_create_buffer
-#define xlu__disk_yy_create_buffer_ALREADY_DEFINED
-#else
-#define yy_create_buffer xlu__disk_yy_create_buffer
-#endif
-
-#ifdef yy_delete_buffer
-#define xlu__disk_yy_delete_buffer_ALREADY_DEFINED
-#else
-#define yy_delete_buffer xlu__disk_yy_delete_buffer
-#endif
-
-#ifdef yy_scan_buffer
-#define xlu__disk_yy_scan_buffer_ALREADY_DEFINED
-#else
-#define yy_scan_buffer xlu__disk_yy_scan_buffer
-#endif
-
-#ifdef yy_scan_string
-#define xlu__disk_yy_scan_string_ALREADY_DEFINED
-#else
-#define yy_scan_string xlu__disk_yy_scan_string
-#endif
-
-#ifdef yy_scan_bytes
-#define xlu__disk_yy_scan_bytes_ALREADY_DEFINED
-#else
-#define yy_scan_bytes xlu__disk_yy_scan_bytes
-#endif
-
-#ifdef yy_init_buffer
-#define xlu__disk_yy_init_buffer_ALREADY_DEFINED
-#else
-#define yy_init_buffer xlu__disk_yy_init_buffer
-#endif
-
-#ifdef yy_flush_buffer
-#define xlu__disk_yy_flush_buffer_ALREADY_DEFINED
-#else
-#define yy_flush_buffer xlu__disk_yy_flush_buffer
-#endif
-
-#ifdef yy_load_buffer_state
-#define xlu__disk_yy_load_buffer_state_ALREADY_DEFINED
-#else
-#define yy_load_buffer_state xlu__disk_yy_load_buffer_state
-#endif
-
-#ifdef yy_switch_to_buffer
-#define xlu__disk_yy_switch_to_buffer_ALREADY_DEFINED
-#else
-#define yy_switch_to_buffer xlu__disk_yy_switch_to_buffer
-#endif
-
-#ifdef yypush_buffer_state
-#define xlu__disk_yypush_buffer_state_ALREADY_DEFINED
-#else
-#define yypush_buffer_state xlu__disk_yypush_buffer_state
-#endif
-
-#ifdef yypop_buffer_state
-#define xlu__disk_yypop_buffer_state_ALREADY_DEFINED
-#else
-#define yypop_buffer_state xlu__disk_yypop_buffer_state
-#endif
-
-#ifdef yyensure_buffer_stack
-#define xlu__disk_yyensure_buffer_stack_ALREADY_DEFINED
-#else
-#define yyensure_buffer_stack xlu__disk_yyensure_buffer_stack
-#endif
-
-#ifdef yylex
-#define xlu__disk_yylex_ALREADY_DEFINED
-#else
-#define yylex xlu__disk_yylex
-#endif
-
-#ifdef yyrestart
-#define xlu__disk_yyrestart_ALREADY_DEFINED
-#else
-#define yyrestart xlu__disk_yyrestart
-#endif
-
-#ifdef yylex_init
-#define xlu__disk_yylex_init_ALREADY_DEFINED
-#else
-#define yylex_init xlu__disk_yylex_init
-#endif
-
-#ifdef yylex_init_extra
-#define xlu__disk_yylex_init_extra_ALREADY_DEFINED
-#else
-#define yylex_init_extra xlu__disk_yylex_init_extra
-#endif
-
-#ifdef yylex_destroy
-#define xlu__disk_yylex_destroy_ALREADY_DEFINED
-#else
-#define yylex_destroy xlu__disk_yylex_destroy
-#endif
-
-#ifdef yyget_debug
-#define xlu__disk_yyget_debug_ALREADY_DEFINED
-#else
-#define yyget_debug xlu__disk_yyget_debug
-#endif
-
-#ifdef yyset_debug
-#define xlu__disk_yyset_debug_ALREADY_DEFINED
-#else
-#define yyset_debug xlu__disk_yyset_debug
-#endif
-
-#ifdef yyget_extra
-#define xlu__disk_yyget_extra_ALREADY_DEFINED
-#else
-#define yyget_extra xlu__disk_yyget_extra
-#endif
-
-#ifdef yyset_extra
-#define xlu__disk_yyset_extra_ALREADY_DEFINED
-#else
-#define yyset_extra xlu__disk_yyset_extra
-#endif
-
-#ifdef yyget_in
-#define xlu__disk_yyget_in_ALREADY_DEFINED
-#else
-#define yyget_in xlu__disk_yyget_in
-#endif
-
-#ifdef yyset_in
-#define xlu__disk_yyset_in_ALREADY_DEFINED
-#else
-#define yyset_in xlu__disk_yyset_in
-#endif
-
-#ifdef yyget_out
-#define xlu__disk_yyget_out_ALREADY_DEFINED
-#else
-#define yyget_out xlu__disk_yyget_out
-#endif
-
-#ifdef yyset_out
-#define xlu__disk_yyset_out_ALREADY_DEFINED
-#else
-#define yyset_out xlu__disk_yyset_out
-#endif
-
-#ifdef yyget_leng
-#define xlu__disk_yyget_leng_ALREADY_DEFINED
-#else
-#define yyget_leng xlu__disk_yyget_leng
-#endif
-
-#ifdef yyget_text
-#define xlu__disk_yyget_text_ALREADY_DEFINED
-#else
-#define yyget_text xlu__disk_yyget_text
-#endif
-
-#ifdef yyget_lineno
-#define xlu__disk_yyget_lineno_ALREADY_DEFINED
-#else
-#define yyget_lineno xlu__disk_yyget_lineno
-#endif
-
-#ifdef yyset_lineno
-#define xlu__disk_yyset_lineno_ALREADY_DEFINED
-#else
-#define yyset_lineno xlu__disk_yyset_lineno
-#endif
-
-#ifdef yyget_column
-#define xlu__disk_yyget_column_ALREADY_DEFINED
-#else
-#define yyget_column xlu__disk_yyget_column
-#endif
-
-#ifdef yyset_column
-#define xlu__disk_yyset_column_ALREADY_DEFINED
-#else
-#define yyset_column xlu__disk_yyset_column
-#endif
-
-#ifdef yywrap
-#define xlu__disk_yywrap_ALREADY_DEFINED
-#else
-#define yywrap xlu__disk_yywrap
-#endif
-
-#ifdef yyalloc
-#define xlu__disk_yyalloc_ALREADY_DEFINED
-#else
-#define yyalloc xlu__disk_yyalloc
-#endif
-
-#ifdef yyrealloc
-#define xlu__disk_yyrealloc_ALREADY_DEFINED
-#else
-#define yyrealloc xlu__disk_yyrealloc
-#endif
-
-#ifdef yyfree
-#define xlu__disk_yyfree_ALREADY_DEFINED
-#else
-#define yyfree xlu__disk_yyfree
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#ifndef SIZE_MAX
-#define SIZE_MAX               (~(size_t)0)
-#endif
-
-#endif /* ! C99 */
-
-#endif /* ! FLEXINT_H */
-
-/* begin standard C++ headers. */
-
-/* TODO: this is always defined, so inline it */
-#define yyconst const
-
-#if defined(__GNUC__) && __GNUC__ >= 3
-#define yynoreturn __attribute__((__noreturn__))
-#else
-#define yynoreturn
-#endif
-
-/* An opaque pointer. */
-#ifndef YY_TYPEDEF_YY_SCANNER_T
-#define YY_TYPEDEF_YY_SCANNER_T
-typedef void* yyscan_t;
-#endif
-
-/* For convenience, these vars (plus the bison vars far below)
-   are macros in the reentrant scanner. */
-#define yyin yyg->yyin_r
-#define yyout yyg->yyout_r
-#define yyextra yyg->yyextra_r
-#define yyleng yyg->yyleng_r
-#define yytext yyg->yytext_r
-#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
-#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
-#define yy_flex_debug yyg->yy_flex_debug_r
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k.
- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
- * Ditto for the __ia64__ case accordingly.
- */
-#define YY_BUF_SIZE 32768
-#else
-#define YY_BUF_SIZE 16384
-#endif /* __ia64__ */
-#endif
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	int yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-void yyrestart ( FILE *input_file , yyscan_t yyscanner );
-void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
-void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-void yypop_buffer_state ( yyscan_t yyscanner );
-
-YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );
-
-void *yyalloc ( yy_size_t , yyscan_t yyscanner );
-void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
-void yyfree ( void * , yyscan_t yyscanner );
-
-#define xlu__disk_yywrap(yyscanner) (/*CONSTCOND*/1)
-#define YY_SKIP_YYWRAP
-
-#define yytext_ptr yytext_r
-
-#ifdef YY_HEADER_EXPORT_START_CONDITIONS
-#define INITIAL 0
-#define LEXERR 1
-
-#endif
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-int yylex_init (yyscan_t* scanner);
-
-int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy ( yyscan_t yyscanner );
-
-int yyget_debug ( yyscan_t yyscanner );
-
-void yyset_debug ( int debug_flag , yyscan_t yyscanner );
-
-YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );
-
-void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );
-
-FILE *yyget_in ( yyscan_t yyscanner );
-
-void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );
-
-FILE *yyget_out ( yyscan_t yyscanner );
-
-void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );
-
-			int yyget_leng ( yyscan_t yyscanner );
-
-char *yyget_text ( yyscan_t yyscanner );
-
-int yyget_lineno ( yyscan_t yyscanner );
-
-void yyset_lineno ( int _line_number , yyscan_t yyscanner );
-
-int yyget_column  ( yyscan_t yyscanner );
-
-void yyset_column ( int _column_no , yyscan_t yyscanner );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap ( yyscan_t yyscanner );
-#else
-extern int yywrap ( yyscan_t yyscanner );
-#endif
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
-#endif
-
-#ifndef YY_NO_INPUT
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k */
-#define YY_READ_BUF_SIZE 16384
-#else
-#define YY_READ_BUF_SIZE 8192
-#endif /* __ia64__ */
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (yyscan_t yyscanner);
-
-#define YY_DECL int yylex (yyscan_t yyscanner)
-#endif /* !YY_DECL */
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-#undef YY_NEW_FILE
-#undef YY_FLUSH_BUFFER
-#undef yy_set_bol
-#undef yy_new_buffer
-#undef yy_set_interactive
-#undef YY_DO_BEFORE_ACTION
-
-#ifdef YY_DECL_IS_OURS
-#undef YY_DECL_IS_OURS
-#undef YY_DECL
-#endif
-
-#ifndef xlu__disk_yy_create_buffer_ALREADY_DEFINED
-#undef yy_create_buffer
-#endif
-#ifndef xlu__disk_yy_delete_buffer_ALREADY_DEFINED
-#undef yy_delete_buffer
-#endif
-#ifndef xlu__disk_yy_scan_buffer_ALREADY_DEFINED
-#undef yy_scan_buffer
-#endif
-#ifndef xlu__disk_yy_scan_string_ALREADY_DEFINED
-#undef yy_scan_string
-#endif
-#ifndef xlu__disk_yy_scan_bytes_ALREADY_DEFINED
-#undef yy_scan_bytes
-#endif
-#ifndef xlu__disk_yy_init_buffer_ALREADY_DEFINED
-#undef yy_init_buffer
-#endif
-#ifndef xlu__disk_yy_flush_buffer_ALREADY_DEFINED
-#undef yy_flush_buffer
-#endif
-#ifndef xlu__disk_yy_load_buffer_state_ALREADY_DEFINED
-#undef yy_load_buffer_state
-#endif
-#ifndef xlu__disk_yy_switch_to_buffer_ALREADY_DEFINED
-#undef yy_switch_to_buffer
-#endif
-#ifndef xlu__disk_yypush_buffer_state_ALREADY_DEFINED
-#undef yypush_buffer_state
-#endif
-#ifndef xlu__disk_yypop_buffer_state_ALREADY_DEFINED
-#undef yypop_buffer_state
-#endif
-#ifndef xlu__disk_yyensure_buffer_stack_ALREADY_DEFINED
-#undef yyensure_buffer_stack
-#endif
-#ifndef xlu__disk_yylex_ALREADY_DEFINED
-#undef yylex
-#endif
-#ifndef xlu__disk_yyrestart_ALREADY_DEFINED
-#undef yyrestart
-#endif
-#ifndef xlu__disk_yylex_init_ALREADY_DEFINED
-#undef yylex_init
-#endif
-#ifndef xlu__disk_yylex_init_extra_ALREADY_DEFINED
-#undef yylex_init_extra
-#endif
-#ifndef xlu__disk_yylex_destroy_ALREADY_DEFINED
-#undef yylex_destroy
-#endif
-#ifndef xlu__disk_yyget_debug_ALREADY_DEFINED
-#undef yyget_debug
-#endif
-#ifndef xlu__disk_yyset_debug_ALREADY_DEFINED
-#undef yyset_debug
-#endif
-#ifndef xlu__disk_yyget_extra_ALREADY_DEFINED
-#undef yyget_extra
-#endif
-#ifndef xlu__disk_yyset_extra_ALREADY_DEFINED
-#undef yyset_extra
-#endif
-#ifndef xlu__disk_yyget_in_ALREADY_DEFINED
-#undef yyget_in
-#endif
-#ifndef xlu__disk_yyset_in_ALREADY_DEFINED
-#undef yyset_in
-#endif
-#ifndef xlu__disk_yyget_out_ALREADY_DEFINED
-#undef yyget_out
-#endif
-#ifndef xlu__disk_yyset_out_ALREADY_DEFINED
-#undef yyset_out
-#endif
-#ifndef xlu__disk_yyget_leng_ALREADY_DEFINED
-#undef yyget_leng
-#endif
-#ifndef xlu__disk_yyget_text_ALREADY_DEFINED
-#undef yyget_text
-#endif
-#ifndef xlu__disk_yyget_lineno_ALREADY_DEFINED
-#undef yyget_lineno
-#endif
-#ifndef xlu__disk_yyset_lineno_ALREADY_DEFINED
-#undef yyset_lineno
-#endif
-#ifndef xlu__disk_yyget_column_ALREADY_DEFINED
-#undef yyget_column
-#endif
-#ifndef xlu__disk_yyset_column_ALREADY_DEFINED
-#undef yyset_column
-#endif
-#ifndef xlu__disk_yywrap_ALREADY_DEFINED
-#undef yywrap
-#endif
-#ifndef xlu__disk_yyget_lval_ALREADY_DEFINED
-#undef yyget_lval
-#endif
-#ifndef xlu__disk_yyset_lval_ALREADY_DEFINED
-#undef yyset_lval
-#endif
-#ifndef xlu__disk_yyget_lloc_ALREADY_DEFINED
-#undef yyget_lloc
-#endif
-#ifndef xlu__disk_yyset_lloc_ALREADY_DEFINED
-#undef yyset_lloc
-#endif
-#ifndef xlu__disk_yyalloc_ALREADY_DEFINED
-#undef yyalloc
-#endif
-#ifndef xlu__disk_yyrealloc_ALREADY_DEFINED
-#undef yyrealloc
-#endif
-#ifndef xlu__disk_yyfree_ALREADY_DEFINED
-#undef yyfree
-#endif
-#ifndef xlu__disk_yytext_ALREADY_DEFINED
-#undef yytext
-#endif
-#ifndef xlu__disk_yyleng_ALREADY_DEFINED
-#undef yyleng
-#endif
-#ifndef xlu__disk_yyin_ALREADY_DEFINED
-#undef yyin
-#endif
-#ifndef xlu__disk_yyout_ALREADY_DEFINED
-#undef yyout
-#endif
-#ifndef xlu__disk_yy_flex_debug_ALREADY_DEFINED
-#undef yy_flex_debug
-#endif
-#ifndef xlu__disk_yylineno_ALREADY_DEFINED
-#undef yylineno
-#endif
-#ifndef xlu__disk_yytables_fload_ALREADY_DEFINED
-#undef yytables_fload
-#endif
-#ifndef xlu__disk_yytables_destroy_ALREADY_DEFINED
-#undef yytables_destroy
-#endif
-#ifndef xlu__disk_yyTABLES_NAME_ALREADY_DEFINED
-#undef yyTABLES_NAME
-#endif
-
-#line 300 "libxlu_disk_l.l"
-
-#line 699 "libxlu_disk_l.h"
-#undef xlu__disk_yyIN_HEADER
-#endif /* xlu__disk_yyHEADER_H */
-- 
Anthony PERARD


